/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _Piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Piece */ \"./src/Piece.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony import */ var _Grab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Grab */ \"./src/Grab.ts\");\n/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Timer */ \"./src/Timer.ts\");\n\n\n\n\n/** 퍼즐에서 아무 퍼즐 조각이나 선택하여, 그 조각의 행렬 위치를 얻는다. */\nfunction selectRealPiece(model, blankTag) {\n    while (true) {\n        let i = Math.floor(Math.random() * model.length);\n        if (model[i] != blankTag)\n            return i;\n    }\n}\n/** 퍼즐의 해결 가능 여부를 실제로 판단한다. */\nfunction checkSolvable(model, blankTag) {\n    let blankIndex = model.indexOf(blankTag);\n    let size = Math.sqrt(model.length);\n    let blankRow = Math.floor(blankIndex / size);\n    let inversion = 0;\n    for (let i = 0; i < model.length; i++) {\n        if (model[i] == blankTag)\n            continue;\n        for (let j = i + 1; j < model.length; j++) {\n            if (model[j] == blankTag)\n                continue;\n            if (model[i] > model[j])\n                inversion++;\n        }\n    }\n    // return inversion % 2 == parity;\n    return (inversion + ((size % 2 == 0) ? blankRow + 1 : 0)) % 2 == 0;\n}\nclass Game {\n    constructor(size, puzzleSet, left, top, boardSize, upsideDown) {\n        /**\n         * 게임 진행 중 여부\n         *\n         * false : 아직 시작 버튼을 누르지 않은 상태.\n         *  - 플레이어는 퍼즐 조각을 요리조리 움직여볼 수 있다.\n         *  - 타이머가 진행되지 않는다.\n         *  - 우연찮게 퍼즐을 완성시켜도 인정하지 않는다.\n         *\n         * true : 플레이 중\n         *  - 타이머가 진행된다.\n         *  - 퍼즐을 완성시키면 클리어한 것으로 인정되고, 완성 이펙트가 뜨고, 이 값이 false로 돌아간다.\n         */\n        this.playing = false;\n        /** 이 게임에서 빈 칸에 해당하는 태그 */\n        this.blankTag = 0;\n        /** 이 게임에서 번호를 표시할지 여부 */\n        this.showLabel = false;\n        this._bottomBlank = true;\n        this._rightBlank = false;\n        /** 퍼즐 조각의 움직임을 컨트롤하는 컴포넌트 */\n        this.grab = new _Grab__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        /** 플레이 타임을 관리하는 컴포넌트 */\n        this.timer = new _Timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n        this.handlePlay = this._noop;\n        this.left = left;\n        this.top = top;\n        this.len = boardSize;\n        this._size = size;\n        this._upsideDown = upsideDown;\n        this.setPuzzleSet(puzzleSet);\n    }\n    /** 캔버스에서 퍼즐의 오른쪽 끝 위치 */\n    get right() { return this.left + this.len; }\n    /** 캔버스에서 퍼즐의 아래쪽 끝 위치 */\n    get bottom() { return this.top + this.len; }\n    /** 한 행 또는 열의 퍼즐 조각의 수 */\n    get size() { return this._size; }\n    /** 퍼즐 조각 하나의 변의 길이 */\n    get pieceSize() { return this.len / this._size; }\n    /** 현재 빈 칸의 행렬 위치 */\n    get rowColOfBlank() {\n        let i = this.puzzleModel.indexOf(this.blankTag);\n        return [Math.floor(i / this._size), i % this._size];\n    }\n    /**\n     * 생성된 퍼즐 조각에 번호를 처음으로 또는 다시 붙인다.\n     * 번호를 붙이는 것은 게임 초기화를 요구하지 않는다.\n     * */\n    assignLabel(upsideDown) {\n        this._upsideDown = upsideDown;\n        const totalPieces = this._size * this._size;\n        for (let tag = 0; tag < totalPieces; tag++) {\n            let vrow = Math.floor(tag / this._size);\n            let vcol = tag % this._size;\n            let lrow = upsideDown ? this._size - vrow - 1 : vrow;\n            let label = lrow * this._size + vcol + 1;\n            this.pieces[tag].label = label.toString();\n        }\n    }\n    /** 퍼즐 크기를 설정한다. 게임 재설정이 요구된다. */\n    setSize(size, bottomBlank, rightBlank) {\n        this.end(null);\n        this.timer.reset();\n        this._size = size;\n        this._bottomBlank = bottomBlank;\n        this._rightBlank = rightBlank;\n        const t = size * size;\n        this.puzzleModel = new Array(t);\n        this.pieces = new Array(t);\n        const pieceLength = this._puzzleSet.size / size;\n        for (let tag = 0; tag < t; tag++) {\n            this.puzzleModel[tag] = tag;\n            let row = Math.floor(tag / size);\n            let col = tag % size;\n            let [x, y] = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getPosition\"])(row, col, this._puzzleSet.size, this._puzzleSet.left, this._puzzleSet.top, size);\n            this.pieces[tag] = new _Piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"](tag, this._puzzleSet.texture, x, y, pieceLength, this.len / size);\n        }\n        this.blankTag = (this._size * (this._size - 1)) * Number(bottomBlank) + (this._size - 1) * Number(rightBlank);\n        this.assignLabel(this._upsideDown);\n        this.initPiecePosition();\n    }\n    /** 퍼즐셋을 변경한다. 참조 범위가 바뀔 수 있으므로 setSize가 후속적으로 실행된다. */\n    setPuzzleSet(puzzleSet) {\n        this._puzzleSet = puzzleSet;\n        this.solvable = puzzleSet.solvable;\n        this.setSize(this._size, this._bottomBlank, this._rightBlank);\n    }\n    /** 퍼즐을 섞는다. Game 내에 있는 solvable 속성이 적용된다. */\n    shuffle() {\n        this.puzzleModel.sort(() => 0.5 - Math.random());\n        if (checkSolvable(this.puzzleModel, this.blankTag) != this.solvable) {\n            let a = selectRealPiece(this.puzzleModel, this.blankTag);\n            let b;\n            do {\n                b = selectRealPiece(this.puzzleModel, this.blankTag);\n            } while (a == b);\n            let t = this.puzzleModel[a];\n            this.puzzleModel[a] = this.puzzleModel[b];\n            this.puzzleModel[b] = t;\n        }\n    }\n    /**\n     * 퍼즐 조각들을 모두 제자리에 놓는다.\n     * (퍼즐 조각의 위치를 퍼즐 모델과 일치시킨다.)\n     * */\n    initPiecePosition() {\n        const totalPieces = this._size * this._size;\n        const num = this._size;\n        const len = this.len;\n        for (let i = 0; i < totalPieces; i++) {\n            const tag = this.puzzleModel[i];\n            let row = Math.floor(i / num);\n            let col = (i % num);\n            let piece = this.pieces[tag];\n            piece.destX = this.left + col * len / num;\n            piece.destY = this.top + row * len / num;\n            piece.getIntoPositionNow();\n        }\n    }\n    /** (x, y) 좌표의 행렬 위치를 얻는다. */\n    getRowColAt(x, y) {\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getRowCol\"])(x, y, this.len, this.left, this.top, this._size);\n    }\n    /** 지정 행렬 위치에 있는 퍼즐 조각을 얻는다. */\n    getPieceAt(row, col) {\n        let foundPosition = col + row * this._size;\n        let foundTag = this.puzzleModel[foundPosition];\n        return this.pieces[foundTag];\n    }\n    /** index번째 행벡터/열벡터를 얻는다. */\n    getVector(index, orient) {\n        let ar = new Array(this._size);\n        let start, increment;\n        switch (orient) {\n            case \"row\":\n                start = index * this._size;\n                increment = 1;\n                break;\n            case \"col\":\n                start = index;\n                increment = this._size;\n                break;\n        }\n        for (let i = 0; i < this._size; i++) {\n            ar[i] = this.pieces[this.puzzleModel[start + increment * i]];\n        }\n        return ar;\n    }\n    /** rAF에 동기화된 마우스 클릭 핸들러 */\n    dispatchMousedown(m) {\n        this.grab.onMousedown(m, this);\n        // 아직 제 자리를 못 찾고 헤매는 조각이 있으면 곧바로 destX,destY 값을 적용시켜 즉시 이동한다.\n        for (const piece of this.pieces) {\n            if (piece.tag != this.blankTag)\n                piece.getIntoPositionNow();\n        }\n    }\n    /** rAF에 동기화된 마우스 놓기 핸들러 */\n    dispatchMouseup(m) {\n        this.grab.onMouseup(m, this);\n    }\n    _noop() { }\n    _updateForPlaying(t) {\n        if (this.isSolved()) {\n            this.onComplete(t);\n            return;\n        }\n        this.timer.update(t);\n    }\n    /** 게임을 시작한다. */\n    start(startTime) {\n        this.handlePlay = this._updateForPlaying;\n        this.playing = true;\n        this.timer.start(startTime);\n    }\n    /** 게임을 끝낸다. (게임 중단, 게임 클리어 모두 포함) */\n    end(endTime) {\n        this.handlePlay = this._noop;\n        this.playing = false;\n        this.timer.end(endTime);\n    }\n    /** 퍼즐이 완성되었는지 판단한다. */\n    isSolved() {\n        for (let i = 0; i < this.puzzleModel.length; i++) {\n            if (this.puzzleModel[i] != i)\n                return false;\n        }\n        return true;\n    }\n    /** 퍼즐을 완성했을 때 실행된다. */\n    onComplete(t) {\n        this.end(t);\n    }\n    /**\n     * 주어진 좌표를 클릭했을 때 마우스 드래그/놓기 이벤트를 활성화시킬 것인지 여부\n     * accept되지 않으면 **입력 자체가 완전히 무시되어 버린다.**\n     */\n    acceptCoordinate(x, y) {\n        // 퍼즐 밖 영역을 클릭하면 드래그로 이어지지 않는다.\n        if (x < this.left || x > this.right || y < this.top || y > this.bottom)\n            return false;\n        // 움직일 수 없는 조각을 클릭하면 드래그로 이어지지 않는다.\n        let [blankRow, blankCol] = this.rowColOfBlank;\n        let [row, col] = this.getRowColAt(x, y);\n        if ((blankRow == row) == (blankCol == col))\n            return false;\n        return true;\n    }\n    /**\n     * 매 rAF마다 호출된다.\n     *\n     * 이게 실행되기 전에 다음 것들이 이 순서대로 실행되었다.\n     * - input.dispatch()\n     * \t- dispatchMousedown, dispatchMouseup이 메시지 큐의 순서에 따라 모두 처리되었다.\n     * - input에 \"현재 상태\" 저장됨\n     *\n     * 이게 실행되고 나면 다음 것들이 차례로 실행될 것이다.\n     * - input.pulse()\n     *  - 현재 값이 이전 값으로(.beforeX, .beforeY) 전이된다.\n     * */\n    update(t, input) {\n        this.handlePlay(t);\n        if (this.grab.piece) {\n            this.grab.update(this, input);\n        }\n        for (const piece of this.pieces) {\n            if (piece.tag != this.blankTag)\n                piece.update(this);\n        }\n        // todo resolveCollision\n    }\n    /** 그린다. */\n    render(context) {\n        context.clearRect(0, 0, 360, 480);\n        for (const piece of this.pieces) {\n            if (piece.tag != this.blankTag)\n                piece.render(context, this.showLabel);\n        }\n        this.timer.render(context, this.left, this.len, 420);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR2FtZS50cz83NDllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0QjtBQUNxQjtBQUN2QjtBQUNFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUFJO0FBQzVCO0FBQ0EseUJBQXlCLDhDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMERBQVc7QUFDcEMsbUNBQW1DLDhDQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvR2FtZS50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQaWVjZSBmcm9tIFwiLi9QaWVjZVwiO1xuaW1wb3J0IHsgZ2V0Um93Q29sLCBnZXRQb3NpdGlvbiB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgR3JhYiBmcm9tIFwiLi9HcmFiXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vVGltZXJcIjtcbi8qKiDtjbzsppDsl5DshJwg7JWE66y0IO2NvOymkCDsobDqsIHsnbTrgpgg7ISg7YOd7ZWY7JesLCDqt7gg7KGw6rCB7J2YIO2WieugrCDsnITsuZjrpbwg7Ja764qU64ukLiAqL1xuZnVuY3Rpb24gc2VsZWN0UmVhbFBpZWNlKG1vZGVsLCBibGFua1RhZykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbW9kZWwubGVuZ3RoKTtcbiAgICAgICAgaWYgKG1vZGVsW2ldICE9IGJsYW5rVGFnKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxufVxuLyoqIO2NvOymkOydmCDtlbTqsrAg6rCA64qlIOyXrOu2gOulvCDsi6TsoJzroZwg7YyQ64uo7ZWc64ukLiAqL1xuZnVuY3Rpb24gY2hlY2tTb2x2YWJsZShtb2RlbCwgYmxhbmtUYWcpIHtcbiAgICBsZXQgYmxhbmtJbmRleCA9IG1vZGVsLmluZGV4T2YoYmxhbmtUYWcpO1xuICAgIGxldCBzaXplID0gTWF0aC5zcXJ0KG1vZGVsLmxlbmd0aCk7XG4gICAgbGV0IGJsYW5rUm93ID0gTWF0aC5mbG9vcihibGFua0luZGV4IC8gc2l6ZSk7XG4gICAgbGV0IGludmVyc2lvbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobW9kZWxbaV0gPT0gYmxhbmtUYWcpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbW9kZWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChtb2RlbFtqXSA9PSBibGFua1RhZylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChtb2RlbFtpXSA+IG1vZGVsW2pdKVxuICAgICAgICAgICAgICAgIGludmVyc2lvbisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBpbnZlcnNpb24gJSAyID09IHBhcml0eTtcbiAgICByZXR1cm4gKGludmVyc2lvbiArICgoc2l6ZSAlIDIgPT0gMCkgPyBibGFua1JvdyArIDEgOiAwKSkgJSAyID09IDA7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBwdXp6bGVTZXQsIGxlZnQsIHRvcCwgYm9hcmRTaXplLCB1cHNpZGVEb3duKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDqsozsnoQg7KeE7ZaJIOykkSDsl6zrtoBcbiAgICAgICAgICpcbiAgICAgICAgICogZmFsc2UgOiDslYTsp4Eg7Iuc7J6RIOuyhO2KvOydhCDriITrpbTsp4Ag7JWK7J2AIOyDge2DnC5cbiAgICAgICAgICogIC0g7ZSM66CI7J207Ja064qUIO2NvOymkCDsobDqsIHsnYQg7JqU66as7KGw66asIOybgOyngeyXrOuzvCDsiJgg7J6I64ukLlxuICAgICAgICAgKiAgLSDtg4DsnbTrqLjqsIAg7KeE7ZaJ65CY7KeAIOyViuuKlOuLpC5cbiAgICAgICAgICogIC0g7Jqw7Jew7LCu6rKMIO2NvOymkOydhCDsmYTshLHsi5zsvJzrj4Qg7J247KCV7ZWY7KeAIOyViuuKlOuLpC5cbiAgICAgICAgICpcbiAgICAgICAgICogdHJ1ZSA6IO2UjOugiOydtCDspJFcbiAgICAgICAgICogIC0g7YOA7J2066i46rCAIOynhO2WieuQnOuLpC5cbiAgICAgICAgICogIC0g7Y287KaQ7J2EIOyZhOyEseyLnO2CpOuptCDtgbTrpqzslrTtlZwg6rKD7Jy866GcIOyduOygleuQmOqzoCwg7JmE7ISxIOydtO2Ome2KuOqwgCDrnKjqs6AsIOydtCDqsJLsnbQgZmFsc2XroZwg64+M7JWE6rCE64ukLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKiDsnbQg6rKM7J6E7JeQ7IScIOu5iCDsubjsl5Ag7ZW064u57ZWY64qUIO2DnOq3uCAqL1xuICAgICAgICB0aGlzLmJsYW5rVGFnID0gMDtcbiAgICAgICAgLyoqIOydtCDqsozsnoTsl5DshJwg67KI7Zi466W8IO2RnOyLnO2VoOyngCDsl6zrtoAgKi9cbiAgICAgICAgdGhpcy5zaG93TGFiZWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYm90dG9tQmxhbmsgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yaWdodEJsYW5rID0gZmFsc2U7XG4gICAgICAgIC8qKiDtjbzsppAg7KGw6rCB7J2YIOybgOyngeyehOydhCDsu6jtirjroaTtlZjripQg7Lu07Y+s64SM7Yq4ICovXG4gICAgICAgIHRoaXMuZ3JhYiA9IG5ldyBHcmFiKCk7XG4gICAgICAgIC8qKiDtlIzroIjsnbQg7YOA7J6E7J2EIOq0gOumrO2VmOuKlCDsu7Ttj6zrhIztirggKi9cbiAgICAgICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcigpO1xuICAgICAgICB0aGlzLmhhbmRsZVBsYXkgPSB0aGlzLl9ub29wO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5sZW4gPSBib2FyZFNpemU7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgICAgICB0aGlzLl91cHNpZGVEb3duID0gdXBzaWRlRG93bjtcbiAgICAgICAgdGhpcy5zZXRQdXp6bGVTZXQocHV6emxlU2V0KTtcbiAgICB9XG4gICAgLyoqIOy6lOuyhOyKpOyXkOyEnCDtjbzsppDsnZgg7Jik66W47Kq9IOuBnSDsnITsuZggKi9cbiAgICBnZXQgcmlnaHQoKSB7IHJldHVybiB0aGlzLmxlZnQgKyB0aGlzLmxlbjsgfVxuICAgIC8qKiDsupTrsoTsiqTsl5DshJwg7Y287KaQ7J2YIOyVhOuemOyqvSDrgZ0g7JyE7LmYICovXG4gICAgZ2V0IGJvdHRvbSgpIHsgcmV0dXJuIHRoaXMudG9wICsgdGhpcy5sZW47IH1cbiAgICAvKiog7ZWcIO2WiSDrmJDripQg7Je07J2YIO2NvOymkCDsobDqsIHsnZgg7IiYICovXG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLl9zaXplOyB9XG4gICAgLyoqIO2NvOymkCDsobDqsIEg7ZWY64KY7J2YIOuzgOydmCDquLjsnbQgKi9cbiAgICBnZXQgcGllY2VTaXplKCkgeyByZXR1cm4gdGhpcy5sZW4gLyB0aGlzLl9zaXplOyB9XG4gICAgLyoqIO2YhOyerCDruYgg7Lm47J2YIO2WieugrCDsnITsuZggKi9cbiAgICBnZXQgcm93Q29sT2ZCbGFuaygpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnB1enpsZU1vZGVsLmluZGV4T2YodGhpcy5ibGFua1RhZyk7XG4gICAgICAgIHJldHVybiBbTWF0aC5mbG9vcihpIC8gdGhpcy5fc2l6ZSksIGkgJSB0aGlzLl9zaXplXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog7IOd7ISx65CcIO2NvOymkCDsobDqsIHsl5Ag67KI7Zi466W8IOyymOydjOycvOuhnCDrmJDripQg64uk7IucIOu2meyduOuLpC5cbiAgICAgKiDrsojtmLjrpbwg67aZ7J2064qUIOqyg+ydgCDqsozsnoQg7LSI6riw7ZmU66W8IOyalOq1rO2VmOyngCDslYrripTri6QuXG4gICAgICogKi9cbiAgICBhc3NpZ25MYWJlbCh1cHNpZGVEb3duKSB7XG4gICAgICAgIHRoaXMuX3Vwc2lkZURvd24gPSB1cHNpZGVEb3duO1xuICAgICAgICBjb25zdCB0b3RhbFBpZWNlcyA9IHRoaXMuX3NpemUgKiB0aGlzLl9zaXplO1xuICAgICAgICBmb3IgKGxldCB0YWcgPSAwOyB0YWcgPCB0b3RhbFBpZWNlczsgdGFnKyspIHtcbiAgICAgICAgICAgIGxldCB2cm93ID0gTWF0aC5mbG9vcih0YWcgLyB0aGlzLl9zaXplKTtcbiAgICAgICAgICAgIGxldCB2Y29sID0gdGFnICUgdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIGxldCBscm93ID0gdXBzaWRlRG93biA/IHRoaXMuX3NpemUgLSB2cm93IC0gMSA6IHZyb3c7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBscm93ICogdGhpcy5fc2l6ZSArIHZjb2wgKyAxO1xuICAgICAgICAgICAgdGhpcy5waWVjZXNbdGFnXS5sYWJlbCA9IGxhYmVsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIO2NvOymkCDtgazquLDrpbwg7ISk7KCV7ZWc64ukLiDqsozsnoQg7J6s7ISk7KCV7J20IOyalOq1rOuQnOuLpC4gKi9cbiAgICBzZXRTaXplKHNpemUsIGJvdHRvbUJsYW5rLCByaWdodEJsYW5rKSB7XG4gICAgICAgIHRoaXMuZW5kKG51bGwpO1xuICAgICAgICB0aGlzLnRpbWVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgICAgICB0aGlzLl9ib3R0b21CbGFuayA9IGJvdHRvbUJsYW5rO1xuICAgICAgICB0aGlzLl9yaWdodEJsYW5rID0gcmlnaHRCbGFuaztcbiAgICAgICAgY29uc3QgdCA9IHNpemUgKiBzaXplO1xuICAgICAgICB0aGlzLnB1enpsZU1vZGVsID0gbmV3IEFycmF5KHQpO1xuICAgICAgICB0aGlzLnBpZWNlcyA9IG5ldyBBcnJheSh0KTtcbiAgICAgICAgY29uc3QgcGllY2VMZW5ndGggPSB0aGlzLl9wdXp6bGVTZXQuc2l6ZSAvIHNpemU7XG4gICAgICAgIGZvciAobGV0IHRhZyA9IDA7IHRhZyA8IHQ7IHRhZysrKSB7XG4gICAgICAgICAgICB0aGlzLnB1enpsZU1vZGVsW3RhZ10gPSB0YWc7XG4gICAgICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcih0YWcgLyBzaXplKTtcbiAgICAgICAgICAgIGxldCBjb2wgPSB0YWcgJSBzaXplO1xuICAgICAgICAgICAgbGV0IFt4LCB5XSA9IGdldFBvc2l0aW9uKHJvdywgY29sLCB0aGlzLl9wdXp6bGVTZXQuc2l6ZSwgdGhpcy5fcHV6emxlU2V0LmxlZnQsIHRoaXMuX3B1enpsZVNldC50b3AsIHNpemUpO1xuICAgICAgICAgICAgdGhpcy5waWVjZXNbdGFnXSA9IG5ldyBQaWVjZSh0YWcsIHRoaXMuX3B1enpsZVNldC50ZXh0dXJlLCB4LCB5LCBwaWVjZUxlbmd0aCwgdGhpcy5sZW4gLyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsYW5rVGFnID0gKHRoaXMuX3NpemUgKiAodGhpcy5fc2l6ZSAtIDEpKSAqIE51bWJlcihib3R0b21CbGFuaykgKyAodGhpcy5fc2l6ZSAtIDEpICogTnVtYmVyKHJpZ2h0QmxhbmspO1xuICAgICAgICB0aGlzLmFzc2lnbkxhYmVsKHRoaXMuX3Vwc2lkZURvd24pO1xuICAgICAgICB0aGlzLmluaXRQaWVjZVBvc2l0aW9uKCk7XG4gICAgfVxuICAgIC8qKiDtjbzsppDshYvsnYQg67OA6rK97ZWc64ukLiDssLjsobAg67KU7JyE6rCAIOuwlOuAlCDsiJgg7J6I7Jy866+A66GcIHNldFNpemXqsIAg7ZuE7IaN7KCB7Jy866GcIOyLpO2WieuQnOuLpC4gKi9cbiAgICBzZXRQdXp6bGVTZXQocHV6emxlU2V0KSB7XG4gICAgICAgIHRoaXMuX3B1enpsZVNldCA9IHB1enpsZVNldDtcbiAgICAgICAgdGhpcy5zb2x2YWJsZSA9IHB1enpsZVNldC5zb2x2YWJsZTtcbiAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuX3NpemUsIHRoaXMuX2JvdHRvbUJsYW5rLCB0aGlzLl9yaWdodEJsYW5rKTtcbiAgICB9XG4gICAgLyoqIO2NvOymkOydhCDshJ7ripTri6QuIEdhbWUg64K07JeQIOyeiOuKlCBzb2x2YWJsZSDsho3shLHsnbQg7KCB7Jqp65Cc64ukLiAqL1xuICAgIHNodWZmbGUoKSB7XG4gICAgICAgIHRoaXMucHV6emxlTW9kZWwuc29ydCgoKSA9PiAwLjUgLSBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgaWYgKGNoZWNrU29sdmFibGUodGhpcy5wdXp6bGVNb2RlbCwgdGhpcy5ibGFua1RhZykgIT0gdGhpcy5zb2x2YWJsZSkge1xuICAgICAgICAgICAgbGV0IGEgPSBzZWxlY3RSZWFsUGllY2UodGhpcy5wdXp6bGVNb2RlbCwgdGhpcy5ibGFua1RhZyk7XG4gICAgICAgICAgICBsZXQgYjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBiID0gc2VsZWN0UmVhbFBpZWNlKHRoaXMucHV6emxlTW9kZWwsIHRoaXMuYmxhbmtUYWcpO1xuICAgICAgICAgICAgfSB3aGlsZSAoYSA9PSBiKTtcbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5wdXp6bGVNb2RlbFthXTtcbiAgICAgICAgICAgIHRoaXMucHV6emxlTW9kZWxbYV0gPSB0aGlzLnB1enpsZU1vZGVsW2JdO1xuICAgICAgICAgICAgdGhpcy5wdXp6bGVNb2RlbFtiXSA9IHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICog7Y287KaQIOyhsOqwgeuTpOydhCDrqqjrkZAg7KCc7J6Q66as7JeQIOuGk+uKlOuLpC5cbiAgICAgKiAo7Y287KaQIOyhsOqwgeydmCDsnITsuZjrpbwg7Y287KaQIOuqqOuNuOqzvCDsnbzsuZjsi5ztgqjri6QuKVxuICAgICAqICovXG4gICAgaW5pdFBpZWNlUG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsUGllY2VzID0gdGhpcy5fc2l6ZSAqIHRoaXMuX3NpemU7XG4gICAgICAgIGNvbnN0IG51bSA9IHRoaXMuX3NpemU7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsUGllY2VzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMucHV6emxlTW9kZWxbaV07XG4gICAgICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpIC8gbnVtKTtcbiAgICAgICAgICAgIGxldCBjb2wgPSAoaSAlIG51bSk7XG4gICAgICAgICAgICBsZXQgcGllY2UgPSB0aGlzLnBpZWNlc1t0YWddO1xuICAgICAgICAgICAgcGllY2UuZGVzdFggPSB0aGlzLmxlZnQgKyBjb2wgKiBsZW4gLyBudW07XG4gICAgICAgICAgICBwaWVjZS5kZXN0WSA9IHRoaXMudG9wICsgcm93ICogbGVuIC8gbnVtO1xuICAgICAgICAgICAgcGllY2UuZ2V0SW50b1Bvc2l0aW9uTm93KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqICh4LCB5KSDsooztkZzsnZgg7ZaJ66CsIOychOy5mOulvCDslrvripTri6QuICovXG4gICAgZ2V0Um93Q29sQXQoeCwgeSkge1xuICAgICAgICByZXR1cm4gZ2V0Um93Q29sKHgsIHksIHRoaXMubGVuLCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLl9zaXplKTtcbiAgICB9XG4gICAgLyoqIOyngOyglSDtlonroKwg7JyE7LmY7JeQIOyeiOuKlCDtjbzsppAg7KGw6rCB7J2EIOyWu+uKlOuLpC4gKi9cbiAgICBnZXRQaWVjZUF0KHJvdywgY29sKSB7XG4gICAgICAgIGxldCBmb3VuZFBvc2l0aW9uID0gY29sICsgcm93ICogdGhpcy5fc2l6ZTtcbiAgICAgICAgbGV0IGZvdW5kVGFnID0gdGhpcy5wdXp6bGVNb2RlbFtmb3VuZFBvc2l0aW9uXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGllY2VzW2ZvdW5kVGFnXTtcbiAgICB9XG4gICAgLyoqIGluZGV467KI7Ke4IO2Wieuyoe2EsC/sl7TrsqHthLDrpbwg7Ja764qU64ukLiAqL1xuICAgIGdldFZlY3RvcihpbmRleCwgb3JpZW50KSB7XG4gICAgICAgIGxldCBhciA9IG5ldyBBcnJheSh0aGlzLl9zaXplKTtcbiAgICAgICAgbGV0IHN0YXJ0LCBpbmNyZW1lbnQ7XG4gICAgICAgIHN3aXRjaCAob3JpZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwicm93XCI6XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleCAqIHRoaXMuX3NpemU7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgICAgICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IHRoaXMuX3NpemU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICAgICAgICAgIGFyW2ldID0gdGhpcy5waWVjZXNbdGhpcy5wdXp6bGVNb2RlbFtzdGFydCArIGluY3JlbWVudCAqIGldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXI7XG4gICAgfVxuICAgIC8qKiByQUbsl5Ag64+Z6riw7ZmU65CcIOuniOyasOyKpCDtgbTrpq0g7ZW465Ok65+sICovXG4gICAgZGlzcGF0Y2hNb3VzZWRvd24obSkge1xuICAgICAgICB0aGlzLmdyYWIub25Nb3VzZWRvd24obSwgdGhpcyk7XG4gICAgICAgIC8vIOyVhOyngSDsoJwg7J6Q66as66W8IOuquyDssL7qs6Ag7Zek66ek64qUIOyhsOqwgeydtCDsnojsnLzrqbQg6rOn67CU66GcIGRlc3RYLGRlc3RZIOqwkuydhCDsoIHsmqnsi5zsvJwg7KaJ7IucIOydtOuPme2VnOuLpC5cbiAgICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiB0aGlzLnBpZWNlcykge1xuICAgICAgICAgICAgaWYgKHBpZWNlLnRhZyAhPSB0aGlzLmJsYW5rVGFnKVxuICAgICAgICAgICAgICAgIHBpZWNlLmdldEludG9Qb3NpdGlvbk5vdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiByQUbsl5Ag64+Z6riw7ZmU65CcIOuniOyasOyKpCDrhpPquLAg7ZW465Ok65+sICovXG4gICAgZGlzcGF0Y2hNb3VzZXVwKG0pIHtcbiAgICAgICAgdGhpcy5ncmFiLm9uTW91c2V1cChtLCB0aGlzKTtcbiAgICB9XG4gICAgX25vb3AoKSB7IH1cbiAgICBfdXBkYXRlRm9yUGxheWluZyh0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU29sdmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyLnVwZGF0ZSh0KTtcbiAgICB9XG4gICAgLyoqIOqyjOyehOydhCDsi5zsnpHtlZzri6QuICovXG4gICAgc3RhcnQoc3RhcnRUaW1lKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGxheSA9IHRoaXMuX3VwZGF0ZUZvclBsYXlpbmc7XG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudGltZXIuc3RhcnQoc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgLyoqIOqyjOyehOydhCDrgZ3rgrjri6QuICjqsozsnoQg7KSR64uoLCDqsozsnoQg7YG066as7Ja0IOuqqOuRkCDtj6ztlagpICovXG4gICAgZW5kKGVuZFRpbWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQbGF5ID0gdGhpcy5fbm9vcDtcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGltZXIuZW5kKGVuZFRpbWUpO1xuICAgIH1cbiAgICAvKiog7Y287KaQ7J20IOyZhOyEseuQmOyXiOuKlOyngCDtjJDri6jtlZzri6QuICovXG4gICAgaXNTb2x2ZWQoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wdXp6bGVNb2RlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMucHV6emxlTW9kZWxbaV0gIT0gaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiDtjbzsppDsnYQg7JmE7ISx7ZaI7J2EIOuVjCDsi6TtlonrkJzri6QuICovXG4gICAgb25Db21wbGV0ZSh0KSB7XG4gICAgICAgIHRoaXMuZW5kKHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDso7zslrTsp4Qg7KKM7ZGc66W8IO2BtOumre2WiOydhCDrlYwg66eI7Jqw7IqkIOuTnOuemOq3uC/rhpPquLAg7J2067Kk7Yq466W8IO2ZnOyEse2ZlOyLnO2CrCDqsoPsnbjsp4Ag7Jes67aAXG4gICAgICogYWNjZXB065CY7KeAIOyViuycvOuptCAqKuyeheugpSDsnpDssrTqsIAg7JmE7KCE7Z6IIOustOyLnOuQmOyWtCDrsoTrprDri6QuKipcbiAgICAgKi9cbiAgICBhY2NlcHRDb29yZGluYXRlKHgsIHkpIHtcbiAgICAgICAgLy8g7Y287KaQIOuwliDsmIHsl63snYQg7YG066at7ZWY66m0IOuTnOuemOq3uOuhnCDsnbTslrTsp4Dsp4Ag7JWK64qU64ukLlxuICAgICAgICBpZiAoeCA8IHRoaXMubGVmdCB8fCB4ID4gdGhpcy5yaWdodCB8fCB5IDwgdGhpcy50b3AgfHwgeSA+IHRoaXMuYm90dG9tKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyDsm4Dsp4Hsnbwg7IiYIOyXhuuKlCDsobDqsIHsnYQg7YG066at7ZWY66m0IOuTnOuemOq3uOuhnCDsnbTslrTsp4Dsp4Ag7JWK64qU64ukLlxuICAgICAgICBsZXQgW2JsYW5rUm93LCBibGFua0NvbF0gPSB0aGlzLnJvd0NvbE9mQmxhbms7XG4gICAgICAgIGxldCBbcm93LCBjb2xdID0gdGhpcy5nZXRSb3dDb2xBdCh4LCB5KTtcbiAgICAgICAgaWYgKChibGFua1JvdyA9PSByb3cpID09IChibGFua0NvbCA9PSBjb2wpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog66ekIHJBRuuniOuLpCDtmLjstpzrkJzri6QuXG4gICAgICpcbiAgICAgKiDsnbTqsowg7Iuk7ZaJ65CY6riwIOyghOyXkCDri6TsnYwg6rKD65Ok7J20IOydtCDsiJzshJzrjIDroZwg7Iuk7ZaJ65CY7JeI64ukLlxuICAgICAqIC0gaW5wdXQuZGlzcGF0Y2goKVxuICAgICAqIFx0LSBkaXNwYXRjaE1vdXNlZG93biwgZGlzcGF0Y2hNb3VzZXVw7J20IOuplOyLnOyngCDtgZDsnZgg7Iic7ISc7JeQIOuUsOudvCDrqqjrkZAg7LKY66as65CY7JeI64ukLlxuICAgICAqIC0gaW5wdXTsl5AgXCLtmITsnqwg7IOB7YOcXCIg7KCA7J6l65CoXG4gICAgICpcbiAgICAgKiDsnbTqsowg7Iuk7ZaJ65CY6rOgIOuCmOuptCDri6TsnYwg6rKD65Ok7J20IOywqOuhgOuhnCDsi6TtlonrkKAg6rKD7J2064ukLlxuICAgICAqIC0gaW5wdXQucHVsc2UoKVxuICAgICAqICAtIO2YhOyerCDqsJLsnbQg7J207KCEIOqwkuycvOuhnCguYmVmb3JlWCwgLmJlZm9yZVkpIOyghOydtOuQnOuLpC5cbiAgICAgKiAqL1xuICAgIHVwZGF0ZSh0LCBpbnB1dCkge1xuICAgICAgICB0aGlzLmhhbmRsZVBsYXkodCk7XG4gICAgICAgIGlmICh0aGlzLmdyYWIucGllY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhYi51cGRhdGUodGhpcywgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGllY2Ugb2YgdGhpcy5waWVjZXMpIHtcbiAgICAgICAgICAgIGlmIChwaWVjZS50YWcgIT0gdGhpcy5ibGFua1RhZylcbiAgICAgICAgICAgICAgICBwaWVjZS51cGRhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbyByZXNvbHZlQ29sbGlzaW9uXG4gICAgfVxuICAgIC8qKiDqt7jrprDri6QuICovXG4gICAgcmVuZGVyKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgMzYwLCA0ODApO1xuICAgICAgICBmb3IgKGNvbnN0IHBpZWNlIG9mIHRoaXMucGllY2VzKSB7XG4gICAgICAgICAgICBpZiAocGllY2UudGFnICE9IHRoaXMuYmxhbmtUYWcpXG4gICAgICAgICAgICAgICAgcGllY2UucmVuZGVyKGNvbnRleHQsIHRoaXMuc2hvd0xhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyLnJlbmRlcihjb250ZXh0LCB0aGlzLmxlZnQsIHRoaXMubGVuLCA0MjApO1xuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Game.ts\n");

/***/ }),

/***/ "./src/Grab.ts":
/*!*********************!*\
  !*** ./src/Grab.ts ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Grab; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n/** 현재 누른 퍼즐 조각과 그 주변 조각에 대한 정보를 가지고 있다. */\nclass Grab {\n    constructor() {\n        /** 현재 누른 퍼즐 조각 */\n        this.piece = null;\n        /** 현재 누른 퍼즐 조각의 원래 행렬 위치 */\n        this.row = null;\n        this.col = null;\n        /** 마우스 버튼이 눌리는 그 순간에 현재 퍼즐 조각의 왼쪽 끝에 상대적인 마우스 위치 */\n        this.pieceOffsetX = null;\n        this.pieceOffsetY = null;\n        /**\n         * 현재 누른 퍼즐 조각과 같은 행 또는 열에 있는 조각들의 모음이다.\n         * 충돌 테스트는 여기 있는 조각들에 한해서 실행된다.\n         */\n        this.concern = null;\n        /**\n         * 현재 누른 퍼즐 조각을 어느 방향으로 움직일 수 있는지 나타낸다.\n         * 이 값이 'h'이면 퍼즐 조각을 좌우좌로 움직일 수 있고, 퍼즐 중에서 행(row)이 선택된 것이다.\n         * 'v'이면 퍼즐 조각을 세로로 움직일 수 있고, 열(col)이 선택된 것이다.\n         */\n        this.moveDirection = null;\n    }\n    /** (rAF-sync) 마우스를 누를 때 실행된다. */\n    onMousedown(m, game) {\n        // 여기서는 [blankRow, blankCol] != [row, col]이다. 만약 둘이 같다면 이것은 실행조차 되지 않는다.\n        let { startX: x, startY: y } = m;\n        let [blankRow, blankCol] = game.rowColOfBlank;\n        let [row, col] = game.getRowColAt(x, y);\n        if (blankRow == row) {\n            this.moveDirection = \"h\";\n            this.concern = game.getVector(blankRow, \"row\");\n        }\n        else if (blankCol == col) {\n            this.moveDirection = \"v\";\n            this.concern = game.getVector(blankCol, \"col\");\n        }\n        this.row = row;\n        this.col = col;\n        this.piece = game.getPieceAt(row, col);\n        this.pieceOffsetX = x - this.piece.x;\n        this.pieceOffsetY = y - this.piece.y;\n    }\n    /** (rAF-sync) 마우스를 놓을 때 실행된다. */\n    onMouseup(m, game) {\n        console.log(m);\n        let { startX, startY, endX, endY, startTime, endTime } = m;\n        let distance = this.moveDirection == 'h' ? endX - startX : endY - startY;\n        /**\n         * # 탭인지 아닌지 판단하는 기준\n         *\n         * 다음 모두를 만족할 것:\n         * - 누르기 시간이 특정 수치를 넘지 않음 (기본 권장 시간 : 0.3초)\n         * - 누적 거리가 특정 길이를 넘기지 않음 (기본 권장 길이 : 10)\n         *\n         * @todo 누적 거리가 아닌 \"변위\"를 가지고 판단한다. 현재 Input에는 누적 이동거리를 판단할 방법이 없다. 근데 변위를 보고 판단하는 것도 나쁘진 않을듯..?\n         */\n        let isTap = (endTime - startTime < 300) && (Math.abs(distance) < 10);\n        if (isTap) {\n            // 퍼즐 조각을 클릭하기만 한 것이라면 모델에서 조각들을 직접 회전시키고, 뷰를 업데이트한다.\n            this.updateModelThenView(game);\n        }\n        else {\n            // 퍼즐 조각을 물리적으로 움직인 것이라면 영향을 받은 모든 조각들을 바른 위치에 놓은 후, 모델을 업데이트한다.\n            this.updateModelByView(game);\n        }\n        // 이제 마우스 놓기 처리가 완전히 끝났을 것이므로 데이터를 정리한다.\n        this.piece = null;\n        this.moveDirection = null;\n        this.concern = null;\n    }\n    /**\n     * 모델을 먼저 바꾸고, 뷰가 모델을 따라도록 한다.\n     * 이 놈은 마우스를 놓을 때에만 실행되며 마우스 놓기 핸들러와 동등한 것으로 본다.\n     */\n    updateModelThenView(game) {\n        /** 태그의 배열 */\n        const vector = [];\n        const start = this.moveDirection == 'h' ? this.row * game.size : this.col;\n        const increment = this.moveDirection == 'h' ? 1 : game.size;\n        // 퍼즐 모델에서 태그의 행벡터 또는 열벡터를 가져온다.\n        for (let i = 0; i < game.size; i++) {\n            let index = start + increment * i;\n            vector[i] = game.puzzleModel[index];\n        }\n        // 클릭한 퍼즐의 태그가 뭐였더라?\n        const currentTag = this.piece.tag;\n        const currentTagPos = vector.indexOf(currentTag);\n        // 빈칸의 위치를 얻는다.\n        const blankTagPos = vector.indexOf(game.blankTag);\n        // 빈칸이 현재 퍼즐 조각보다 뒤에(오른쪽 또는 아래) 있는지, 앞에 있는지(왼쪽 또는 위)를 판단한여 회전을 시킨다.\n        if (currentTagPos < blankTagPos) {\n            vector.splice(blankTagPos, 1);\n            vector.splice(currentTagPos, 0, game.blankTag);\n        }\n        else {\n            vector.splice(blankTagPos, 1);\n            vector.splice(currentTagPos, 0, game.blankTag);\n        }\n        // 변경된 모델을 기반으로 조각들의 위치를 업데이트한다.\n        for (let i = 0; i < game.size; i++) {\n            let index = start + increment * i;\n            game.puzzleModel[index] = vector[i];\n            let p = game.pieces[vector[i]];\n            let [row, col] = [Math.floor(index / game.size), index % game.size];\n            let [destX, destY] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getPosition\"])(row, col, game.len, game.left, game.top, game.size);\n            p.destX = destX;\n            p.destY = destY;\n        }\n    }\n    /**\n     * 영향을 받은 퍼즐 조각들의 현재 위치(Piece.prototype.x, Piece.prototype.y)만을 가지고\n     * 모델을 업데이트한다. 이 놈은 마우스를 놓을 때에만 실행되며 마우스 놓기 핸들러와 동등한 것으로 본다.\n     * @deprecated 속도는 전혀 고려되지 않는다.\n     */\n    updateModelByView(game) {\n        let modelChanges = {};\n        for (const piece of this.concern) {\n            if (piece.tag == game.blankTag)\n                continue;\n            // 영향을 받은 모든 퍼즐 조각들의 모델 행렬 위치를 얻는다. \n            let [row, col] = piece.whereami(game.left, game.top, game.len, game.size);\n            // 변경점에 퍼즐 조각의 새로운 위치를 설정한다.\n            modelChanges[row * game.size + col] = piece.tag;\n            // 조각이 새로운 위치로 이동하도록 destX, destY를 설정한다.\n            let destX = game.left + col * game.pieceSize;\n            let destY = game.top + row * game.pieceSize;\n            piece.destX = destX;\n            piece.destY = destY;\n        }\n        // 옮기기 이후 모델의 변경점(changes)을 찾는다.\n        const start = this.moveDirection == 'h' ? this.row * game.size : this.col;\n        const increment = this.moveDirection == 'h' ? 1 : game.size;\n        // 빈칸을 찾는다.\n        for (let i = 0; i < game.size; i++) {\n            let index = start + increment * i;\n            if (!(index in modelChanges)) {\n                modelChanges[index] = game.blankTag;\n                break;\n            }\n        }\n        // 변경점을 퍼즐 모델에 적용시킨다.\n        for (const index in modelChanges) {\n            const tag = modelChanges[index];\n            game.puzzleModel[index] = tag;\n        }\n    }\n    /** 마우스를 누르고 있는 때에 한해 업데이트(rAF)가 발생할 때 호출된다. 즉, 실질적 업데이트와 같다. */\n    update(game, holdInput) {\n        if (this.moveDirection == \"h\" && holdInput.beforeX != null) {\n            let x = holdInput.x - this.pieceOffsetX;\n            this.piece.velX = x - this.piece.x;\n        }\n        else if (this.moveDirection == \"v\" && holdInput.beforeY != null) {\n            let y = holdInput.y - this.pieceOffsetY;\n            this.piece.velY = y - this.piece.y;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JhYi50cz81ZTZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFzQztBQUN0QztBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFpRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL0dyYWIudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRQb3NpdGlvbiB9IGZyb20gXCIuL3V0aWxzXCI7XG4vKiog7ZiE7J6sIOuIhOuluCDtjbzsppAg7KGw6rCB6rO8IOq3uCDso7zrs4Ag7KGw6rCB7JeQIOuMgO2VnCDsoJXrs7Trpbwg6rCA7KeA6rOgIOyeiOuLpC4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYWIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiog7ZiE7J6sIOuIhOuluCDtjbzsppAg7KGw6rCBICovXG4gICAgICAgIHRoaXMucGllY2UgPSBudWxsO1xuICAgICAgICAvKiog7ZiE7J6sIOuIhOuluCDtjbzsppAg7KGw6rCB7J2YIOybkOuemCDtlonroKwg7JyE7LmYICovXG4gICAgICAgIHRoaXMucm93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2wgPSBudWxsO1xuICAgICAgICAvKiog66eI7Jqw7IqkIOuyhO2KvOydtCDriIzrpqzripQg6re4IOyInOqwhOyXkCDtmITsnqwg7Y287KaQIOyhsOqwgeydmCDsmbzsqr0g64Gd7JeQIOyDgeuMgOyggeyduCDrp4jsmrDsiqQg7JyE7LmYICovXG4gICAgICAgIHRoaXMucGllY2VPZmZzZXRYID0gbnVsbDtcbiAgICAgICAgdGhpcy5waWVjZU9mZnNldFkgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICog7ZiE7J6sIOuIhOuluCDtjbzsppAg7KGw6rCB6rO8IOqwmeydgCDtlokg65iQ64qUIOyXtOyXkCDsnojripQg7KGw6rCB65Ok7J2YIOuqqOydjOydtOuLpC5cbiAgICAgICAgICog7Lap64+MIO2FjOyKpO2KuOuKlCDsl6zquLAg7J6I64qUIOyhsOqwgeuTpOyXkCDtlZztlbTshJwg7Iuk7ZaJ65Cc64ukLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25jZXJuID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIO2YhOyerCDriITrpbgg7Y287KaQIOyhsOqwgeydhCDslrTripAg67Cp7Zal7Jy866GcIOybgOyngeydvCDsiJgg7J6I64qU7KeAIOuCmO2DgOuCuOuLpC5cbiAgICAgICAgICog7J20IOqwkuydtCAnaCfsnbTrqbQg7Y287KaQIOyhsOqwgeydhCDsoozsmrDsoozroZwg7JuA7KeB7J28IOyImCDsnojqs6AsIO2NvOymkCDspJHsl5DshJwg7ZaJKHJvdynsnbQg7ISg7YOd65CcIOqyg+ydtOuLpC5cbiAgICAgICAgICogJ3Yn7J2066m0IO2NvOymkCDsobDqsIHsnYQg7IS466Gc66GcIOybgOyngeydvCDsiJgg7J6I6rOgLCDsl7QoY29sKeydtCDshKDtg53rkJwg6rKD7J2064ukLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgLyoqIChyQUYtc3luYykg66eI7Jqw7Iqk66W8IOuIhOulvCDrlYwg7Iuk7ZaJ65Cc64ukLiAqL1xuICAgIG9uTW91c2Vkb3duKG0sIGdhbWUpIHtcbiAgICAgICAgLy8g7Jes6riw7ISc64qUIFtibGFua1JvdywgYmxhbmtDb2xdICE9IFtyb3csIGNvbF3snbTri6QuIOunjOyVvSDrkZjsnbQg6rCZ64uk66m0IOydtOqyg+ydgCDsi6TtlonsobDssKgg65CY7KeAIOyViuuKlOuLpC5cbiAgICAgICAgbGV0IHsgc3RhcnRYOiB4LCBzdGFydFk6IHkgfSA9IG07XG4gICAgICAgIGxldCBbYmxhbmtSb3csIGJsYW5rQ29sXSA9IGdhbWUucm93Q29sT2ZCbGFuaztcbiAgICAgICAgbGV0IFtyb3csIGNvbF0gPSBnYW1lLmdldFJvd0NvbEF0KHgsIHkpO1xuICAgICAgICBpZiAoYmxhbmtSb3cgPT0gcm93KSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBcImhcIjtcbiAgICAgICAgICAgIHRoaXMuY29uY2VybiA9IGdhbWUuZ2V0VmVjdG9yKGJsYW5rUm93LCBcInJvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibGFua0NvbCA9PSBjb2wpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZURpcmVjdGlvbiA9IFwidlwiO1xuICAgICAgICAgICAgdGhpcy5jb25jZXJuID0gZ2FtZS5nZXRWZWN0b3IoYmxhbmtDb2wsIFwiY29sXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93ID0gcm93O1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICAgICAgdGhpcy5waWVjZSA9IGdhbWUuZ2V0UGllY2VBdChyb3csIGNvbCk7XG4gICAgICAgIHRoaXMucGllY2VPZmZzZXRYID0geCAtIHRoaXMucGllY2UueDtcbiAgICAgICAgdGhpcy5waWVjZU9mZnNldFkgPSB5IC0gdGhpcy5waWVjZS55O1xuICAgIH1cbiAgICAvKiogKHJBRi1zeW5jKSDrp4jsmrDsiqTrpbwg64aT7J2EIOuVjCDsi6TtlonrkJzri6QuICovXG4gICAgb25Nb3VzZXVwKG0sIGdhbWUpIHtcbiAgICAgICAgY29uc29sZS5sb2cobSk7XG4gICAgICAgIGxldCB7IHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBzdGFydFRpbWUsIGVuZFRpbWUgfSA9IG07XG4gICAgICAgIGxldCBkaXN0YW5jZSA9IHRoaXMubW92ZURpcmVjdGlvbiA9PSAnaCcgPyBlbmRYIC0gc3RhcnRYIDogZW5kWSAtIHN0YXJ0WTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICMg7YOt7J247KeAIOyVhOuLjOyngCDtjJDri6jtlZjripQg6riw7KSAXG4gICAgICAgICAqXG4gICAgICAgICAqIOuLpOydjCDrqqjrkZDrpbwg66eM7KGx7ZWgIOqygzpcbiAgICAgICAgICogLSDriITrpbTquLAg7Iuc6rCE7J20IO2KueyglSDsiJjsuZjrpbwg64SY7KeAIOyViuydjCAo6riw67O4IOq2jOyepSDsi5zqsIQgOiAwLjPstIgpXG4gICAgICAgICAqIC0g64iE7KCBIOqxsOumrOqwgCDtirnsoJUg6ri47J2066W8IOuEmOq4sOyngCDslYrsnYwgKOq4sOuzuCDqtozsnqUg6ri47J20IDogMTApXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0b2RvIOuIhOyggSDqsbDrpqzqsIAg7JWE64uMIFwi67OA7JyEXCLrpbwg6rCA7KeA6rOgIO2MkOuLqO2VnOuLpC4g7ZiE7J6sIElucHV07JeQ64qUIOuIhOyggSDsnbTrj5nqsbDrpqzrpbwg7YyQ64uo7ZWgIOuwqeuyleydtCDsl4bri6QuIOq3vOuNsCDrs4DsnITrpbwg67O06rOgIO2MkOuLqO2VmOuKlCDqsoPrj4Qg64KY7IGY7KeEIOyViuydhOuTry4uP1xuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGlzVGFwID0gKGVuZFRpbWUgLSBzdGFydFRpbWUgPCAzMDApICYmIChNYXRoLmFicyhkaXN0YW5jZSkgPCAxMCk7XG4gICAgICAgIGlmIChpc1RhcCkge1xuICAgICAgICAgICAgLy8g7Y287KaQIOyhsOqwgeydhCDtgbTrpq3tlZjquLDrp4wg7ZWcIOqyg+ydtOudvOuptCDrqqjrjbjsl5DshJwg7KGw6rCB65Ok7J2EIOyngeygkSDtmozsoITsi5ztgqTqs6AsIOu3sOulvCDsl4XrjbDsnbTtirjtlZzri6QuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsVGhlblZpZXcoZ2FtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDtjbzsppAg7KGw6rCB7J2EIOusvOumrOyggeycvOuhnCDsm4Dsp4Hsnbgg6rKD7J20652866m0IOyYge2WpeydhCDrsJvsnYAg66qo65OgIOyhsOqwgeuTpOydhCDrsJTrpbgg7JyE7LmY7JeQIOuGk+ydgCDtm4QsIOuqqOuNuOydhCDsl4XrjbDsnbTtirjtlZzri6QuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsQnlWaWV3KGdhbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIOydtOygnCDrp4jsmrDsiqQg64aT6riwIOyymOumrOqwgCDsmYTsoITtnogg64Gd64Ks7J2EIOqyg+ydtOuvgOuhnCDrjbDsnbTthLDrpbwg7KCV66as7ZWc64ukLlxuICAgICAgICB0aGlzLnBpZWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25jZXJuID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog66qo64247J2EIOuovOyggCDrsJTqvrjqs6AsIOu3sOqwgCDrqqjrjbjsnYQg65Sw652864+E66GdIO2VnOuLpC5cbiAgICAgKiDsnbQg64aI7J2AIOuniOyasOyKpOulvCDrhpPsnYQg65WM7JeQ66eMIOyLpO2WieuQmOupsCDrp4jsmrDsiqQg64aT6riwIO2VuOuTpOufrOyZgCDrj5nrk7HtlZwg6rKD7Jy866GcIOuzuOuLpC5cbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbFRoZW5WaWV3KGdhbWUpIHtcbiAgICAgICAgLyoqIO2DnOq3uOydmCDrsLDsl7QgKi9cbiAgICAgICAgY29uc3QgdmVjdG9yID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5tb3ZlRGlyZWN0aW9uID09ICdoJyA/IHRoaXMucm93ICogZ2FtZS5zaXplIDogdGhpcy5jb2w7XG4gICAgICAgIGNvbnN0IGluY3JlbWVudCA9IHRoaXMubW92ZURpcmVjdGlvbiA9PSAnaCcgPyAxIDogZ2FtZS5zaXplO1xuICAgICAgICAvLyDtjbzsppAg66qo64247JeQ7IScIO2DnOq3uOydmCDtlonrsqHthLAg65iQ64qUIOyXtOuyoe2EsOulvCDqsIDsoLjsmKjri6QuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2FtZS5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHN0YXJ0ICsgaW5jcmVtZW50ICogaTtcbiAgICAgICAgICAgIHZlY3RvcltpXSA9IGdhbWUucHV6emxlTW9kZWxbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIC8vIO2BtOumre2VnCDtjbzsppDsnZgg7YOc6re46rCAIOutkOyYgOuNlOudvD9cbiAgICAgICAgY29uc3QgY3VycmVudFRhZyA9IHRoaXMucGllY2UudGFnO1xuICAgICAgICBjb25zdCBjdXJyZW50VGFnUG9zID0gdmVjdG9yLmluZGV4T2YoY3VycmVudFRhZyk7XG4gICAgICAgIC8vIOu5iOy5uOydmCDsnITsuZjrpbwg7Ja764qU64ukLlxuICAgICAgICBjb25zdCBibGFua1RhZ1BvcyA9IHZlY3Rvci5pbmRleE9mKGdhbWUuYmxhbmtUYWcpO1xuICAgICAgICAvLyDruYjsubjsnbQg7ZiE7J6sIO2NvOymkCDsobDqsIHrs7Tri6Qg65Kk7JeQKOyYpOuluOyqvSDrmJDripQg7JWE656YKSDsnojripTsp4AsIOyVnuyXkCDsnojripTsp4Ao7Jm87Kq9IOuYkOuKlCDsnIQp66W8IO2MkOuLqO2VnOyXrCDtmozsoITsnYQg7Iuc7YKo64ukLlxuICAgICAgICBpZiAoY3VycmVudFRhZ1BvcyA8IGJsYW5rVGFnUG9zKSB7XG4gICAgICAgICAgICB2ZWN0b3Iuc3BsaWNlKGJsYW5rVGFnUG9zLCAxKTtcbiAgICAgICAgICAgIHZlY3Rvci5zcGxpY2UoY3VycmVudFRhZ1BvcywgMCwgZ2FtZS5ibGFua1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ZWN0b3Iuc3BsaWNlKGJsYW5rVGFnUG9zLCAxKTtcbiAgICAgICAgICAgIHZlY3Rvci5zcGxpY2UoY3VycmVudFRhZ1BvcywgMCwgZ2FtZS5ibGFua1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8g67OA6rK965CcIOuqqOuNuOydhCDquLDrsJjsnLzroZwg7KGw6rCB65Ok7J2YIOychOy5mOulvCDsl4XrjbDsnbTtirjtlZzri6QuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2FtZS5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHN0YXJ0ICsgaW5jcmVtZW50ICogaTtcbiAgICAgICAgICAgIGdhbWUucHV6emxlTW9kZWxbaW5kZXhdID0gdmVjdG9yW2ldO1xuICAgICAgICAgICAgbGV0IHAgPSBnYW1lLnBpZWNlc1t2ZWN0b3JbaV1dO1xuICAgICAgICAgICAgbGV0IFtyb3csIGNvbF0gPSBbTWF0aC5mbG9vcihpbmRleCAvIGdhbWUuc2l6ZSksIGluZGV4ICUgZ2FtZS5zaXplXTtcbiAgICAgICAgICAgIGxldCBbZGVzdFgsIGRlc3RZXSA9IGdldFBvc2l0aW9uKHJvdywgY29sLCBnYW1lLmxlbiwgZ2FtZS5sZWZ0LCBnYW1lLnRvcCwgZ2FtZS5zaXplKTtcbiAgICAgICAgICAgIHAuZGVzdFggPSBkZXN0WDtcbiAgICAgICAgICAgIHAuZGVzdFkgPSBkZXN0WTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDsmIHtlqXsnYQg67Cb7J2AIO2NvOymkCDsobDqsIHrk6TsnZgg7ZiE7J6sIOychOy5mChQaWVjZS5wcm90b3R5cGUueCwgUGllY2UucHJvdG90eXBlLnkp66eM7J2EIOqwgOyngOqzoFxuICAgICAqIOuqqOuNuOydhCDsl4XrjbDsnbTtirjtlZzri6QuIOydtCDrhojsnYAg66eI7Jqw7Iqk66W8IOuGk+ydhCDrlYzsl5Drp4wg7Iuk7ZaJ65CY66mwIOuniOyasOyKpCDrhpPquLAg7ZW465Ok65+s7JmAIOuPmeuTse2VnCDqsoPsnLzroZwg67O464ukLlxuICAgICAqIEBkZXByZWNhdGVkIOyGjeuPhOuKlCDsoITtmIAg6rOg66Ck65CY7KeAIOyViuuKlOuLpC5cbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbEJ5VmlldyhnYW1lKSB7XG4gICAgICAgIGxldCBtb2RlbENoYW5nZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiB0aGlzLmNvbmNlcm4pIHtcbiAgICAgICAgICAgIGlmIChwaWVjZS50YWcgPT0gZ2FtZS5ibGFua1RhZylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIOyYge2WpeydhCDrsJvsnYAg66qo65OgIO2NvOymkCDsobDqsIHrk6TsnZgg66qo6424IO2WieugrCDsnITsuZjrpbwg7Ja764qU64ukLiBcbiAgICAgICAgICAgIGxldCBbcm93LCBjb2xdID0gcGllY2Uud2hlcmVhbWkoZ2FtZS5sZWZ0LCBnYW1lLnRvcCwgZ2FtZS5sZW4sIGdhbWUuc2l6ZSk7XG4gICAgICAgICAgICAvLyDrs4Dqsr3soJDsl5Ag7Y287KaQIOyhsOqwgeydmCDsg4jroZzsmrQg7JyE7LmY66W8IOyEpOygle2VnOuLpC5cbiAgICAgICAgICAgIG1vZGVsQ2hhbmdlc1tyb3cgKiBnYW1lLnNpemUgKyBjb2xdID0gcGllY2UudGFnO1xuICAgICAgICAgICAgLy8g7KGw6rCB7J20IOyDiOuhnOyatCDsnITsuZjroZwg7J2064+Z7ZWY64+E66GdIGRlc3RYLCBkZXN0WeulvCDshKTsoJXtlZzri6QuXG4gICAgICAgICAgICBsZXQgZGVzdFggPSBnYW1lLmxlZnQgKyBjb2wgKiBnYW1lLnBpZWNlU2l6ZTtcbiAgICAgICAgICAgIGxldCBkZXN0WSA9IGdhbWUudG9wICsgcm93ICogZ2FtZS5waWVjZVNpemU7XG4gICAgICAgICAgICBwaWVjZS5kZXN0WCA9IGRlc3RYO1xuICAgICAgICAgICAgcGllY2UuZGVzdFkgPSBkZXN0WTtcbiAgICAgICAgfVxuICAgICAgICAvLyDsmK7quLDquLAg7J207ZuEIOuqqOuNuOydmCDrs4Dqsr3soJAoY2hhbmdlcynsnYQg7LC+64qU64ukLlxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMubW92ZURpcmVjdGlvbiA9PSAnaCcgPyB0aGlzLnJvdyAqIGdhbWUuc2l6ZSA6IHRoaXMuY29sO1xuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSB0aGlzLm1vdmVEaXJlY3Rpb24gPT0gJ2gnID8gMSA6IGdhbWUuc2l6ZTtcbiAgICAgICAgLy8g67mI7Lm47J2EIOywvuuKlOuLpC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lLnNpemU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gc3RhcnQgKyBpbmNyZW1lbnQgKiBpO1xuICAgICAgICAgICAgaWYgKCEoaW5kZXggaW4gbW9kZWxDaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsQ2hhbmdlc1tpbmRleF0gPSBnYW1lLmJsYW5rVGFnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOuzgOqyveygkOydhCDtjbzsppAg66qo64247JeQIOyggeyaqeyLnO2CqOuLpC5cbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiBtb2RlbENoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IG1vZGVsQ2hhbmdlc1tpbmRleF07XG4gICAgICAgICAgICBnYW1lLnB1enpsZU1vZGVsW2luZGV4XSA9IHRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiog66eI7Jqw7Iqk66W8IOuIhOultOqzoCDsnojripQg65WM7JeQIO2VnO2VtCDsl4XrjbDsnbTtirgockFGKeqwgCDrsJzsg53tlaAg65WMIO2YuOy2nOuQnOuLpC4g7KaJLCDsi6Tsp4jsoIEg7JeF642w7J207Yq47JmAIOqwmeuLpC4gKi9cbiAgICB1cGRhdGUoZ2FtZSwgaG9sZElucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVEaXJlY3Rpb24gPT0gXCJoXCIgJiYgaG9sZElucHV0LmJlZm9yZVggIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHggPSBob2xkSW5wdXQueCAtIHRoaXMucGllY2VPZmZzZXRYO1xuICAgICAgICAgICAgdGhpcy5waWVjZS52ZWxYID0geCAtIHRoaXMucGllY2UueDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vdmVEaXJlY3Rpb24gPT0gXCJ2XCIgJiYgaG9sZElucHV0LmJlZm9yZVkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHkgPSBob2xkSW5wdXQueSAtIHRoaXMucGllY2VPZmZzZXRZO1xuICAgICAgICAgICAgdGhpcy5waWVjZS52ZWxZID0geSAtIHRoaXMucGllY2UueTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Grab.ts\n");

/***/ }),

/***/ "./src/Input.ts":
/*!**********************!*\
  !*** ./src/Input.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MouseInput; });\n/**\n * 마우스 입력을 받아들여서 리스너에게 전달하는 클래스\n * 이 클래스는 requestAnimationFrame()을 사용한 업데이트 패턴에 특화된 구조를 가지고 있다.\n * 중요하고 양이 비교적 적은 이벤트(마우스 누름, 마우스 놓음)는 매 이벤트 루프마다 놓치지 않고 캡쳐해 두고, 압도적으로 많이 발생하고 중요하지 않은 이벤트(마우스 움직임)는 변화에 따라 \"현재 상태\"와 \"직전 상태\"만을 저장해 두고 rAF에서 그 상태를 참조하도록 하고 있다.\n */\nclass MouseInput {\n    constructor() {\n        /** 중요 이벤트(마우스 누름, 마우스 놓음)를 저장한 큐 */\n        this.messages = [];\n        /**\n         * DOM 이벤트가 발생했을 때 임시적으로 캡쳐한 마우스 위치\n         * 이것은 이동, 누름, 놓음 모든 종류의 이벤트를 받아들인다\n         * Listener가 마우스 좌표를 받아들이면 퍼즐 조각에 바로 반영하지 않고, requestAnimationFrame이 돌아올 때까지 기다린다. (이벤트 핸들링이 rAF보다 훨씬 많이 발생한다.)\n         * 따라서 쏟아지는 이벤트로 인해 불필요하게 성능이 저하되는 것을 방지한다.\n         * 어떤 이벤트 루프에서 rAF가 발생하지 않으면 해당 루프로 받아들인 좌표는 버려지게 된다.\n         * */\n        this.inputX = null;\n        this.inputY = null;\n        /**\n         * inputX, inputY는 드래그를 하는 한에서는 현재 위치로 사용될 수 있으나,\n         * 드래그를 하지 않는 동안에는 마지막으로 마우스 이벤트가 일어난 지점이 계속 저장되어 있다.\n         * 게다가 update()에서 dispatch와 pulse는 마우스 눌림 여부와 관계없이 항상 실행된다.\n         * 따라서 inputX, inputY는 \"현재\"를 나타내기에는 부적절하다.\n        */\n        this.currentX = null;\n        this.currentY = null;\n        /** (private) 마지막 update(rAF)가 발생하기 직전의 마우스 위치 */\n        this._beforeX = null;\n        this._beforeY = null;\n        /**\n         * 마우스 누름 발생 시, 언젠가 발생할 마우스 떼기에 대응하여 임시로 메시지를 만들어 저장해 둘 배열\n         * messagePool[n]은 n번 마우스 버튼 누름에 대응하는 임시 마우스 떼기 메시지이다.\n         * n번 마우스 버튼 떼기가 발생하면 messagePool[n]에 있는 메시지를 꺼내서 end 값을 입력하고 큐에 넣는다.\n         * */\n        this.messagePool = [];\n        this.mousedown = (ev) => {\n            ev.preventDefault();\n            // @todo : acceptCoordinate때문에 listener가 단 하나이어야 한다는 제약이 추가되었다\n            if (this.listener.acceptCoordinate(ev.offsetX, ev.offsetY)) {\n                console.log(ev.offsetX);\n                // pulse를 맞으면 currentX는 beforeX가 된다.\n                // 따라서 rAF가 발생하는 시점에서 이전 위치는 마우스 누름 위치로 간주된다.\n                this.currentX = ev.offsetX;\n                this.currentY = ev.offsetY;\n                // 이것과 rAF 사이에 move가 발생하지 않으면 rAF 발생 시 혀재 위치 또한 마우스 누름 위치가 된다.\n                // rAF 발생 전에 move가 먼저 발생하면 input값을 덮어써서 걔들이 current값이 되겠지?\n                this.inputX = ev.offsetX;\n                this.inputY = ev.offsetY;\n                this.source.addEventListener('mousemove', this.mousemove);\n                document.addEventListener('mouseup', this.mouseup);\n                // 마우스 누름 이벤트를 입력한다.\n                this.messages.push({\n                    type: \"mousedown\",\n                    x: ev.offsetX,\n                    y: ev.offsetY,\n                    t: ev.timeStamp,\n                    startX: ev.offsetX,\n                    startY: ev.offsetY,\n                    startTime: ev.timeStamp\n                });\n                // down-up pair를 위해 마우스 누름 위치를 저장한다.\n                this.messagePool[ev.button] = {\n                    type: \"mouseup\",\n                    startX: ev.offsetX,\n                    startY: ev.offsetY,\n                    startTime: ev.timeStamp\n                };\n            }\n            return false;\n        };\n        this.mousemove = (ev) => {\n            this.inputX = ev.offsetX;\n            this.inputY = ev.offsetY;\n        };\n        this.mouseup = (ev) => {\n            /* MouseEvent.offsetX는 source 상대 위치이다. 띠용! */\n            let x = ev.offsetX;\n            let y = ev.offsetY;\n            // 마우스 누름 당시 저장했던 마우스 놓기 메시지를 가져온다.\n            let message = this.messagePool[ev.button];\n            delete this.messagePool[ev.button];\n            // 비로소 마우스 떼기 정보를 얻었으니 그 정보를 입력한다.\n            message.endX = x;\n            message.endY = y;\n            message.endTime = ev.timeStamp;\n            // 메시지를 입력한다.\n            this.messages.push(message);\n            // 현재 rAF의 마우스 위치를 떼기 위치로 간주한다.\n            // input에다 좌표를 넣어두면 rAF 발생 시 current로 내려가겠지?\n            this.inputX = x;\n            this.inputY = y;\n            this.source.removeEventListener('mousemove', this.mousemove);\n            document.removeEventListener('mouseup', this.mouseup);\n        };\n    }\n    /** 현재 마우스 위치 */\n    get x() { return this.currentX; }\n    get y() { return this.currentY; }\n    /** 마지막 update(rAF)가 발생하기 직전의 마우스 위치 */\n    get beforeX() { return this._beforeX; }\n    get beforeY() { return this._beforeY; }\n    /** update(rAF) 간의 x, y 변화량 */\n    get moveX() {\n        return (this.beforeX != null) && (this.currentX != null) ? (this.currentX - this._beforeX) : 0;\n    }\n    get moveY() {\n        return (this.beforeY != null) && (this.currentY != null) ? (this.currentY - this._beforeY) : 0;\n    }\n    /** 입력 컴포넌트를 뷰에 연결한다. */\n    connect(source, listener) {\n        this.disconnect();\n        this.source = source;\n        this.listener = listener;\n        this.source.addEventListener('mousedown', this.mousedown);\n    }\n    /** 입력 컴포넌트 연결을 해제한다. */\n    disconnect() {\n        let source = this.source;\n        if (source) {\n            source.removeEventListener('mousedown', this.mousedown);\n            source.removeEventListener('mousemove', this.mousemove);\n            document.removeEventListener('mouseup', this.mouseup);\n        }\n        this.source = null;\n        this.listener = null;\n    }\n    /**\n     * (rAF) 큐에 있는 메시지를 모두 정리하고, 상태를 전이시킨다.\n     *\n     * # 중요 : 디스패치는 currentX|Y, beforeX|Y, moveX|Y와는 좆도 상관 없다고 씨발놈아!!\n     * */\n    update() {\n        // dispatch\n        let message;\n        while ((message = this.messages.shift()) != null) {\n            switch (message.type) {\n                case \"mousedown\":\n                    this.listener.dispatchMousedown(message);\n                    break;\n                case \"mouseup\":\n                    this.listener.dispatchMouseup(message);\n                    break;\n            }\n        }\n        // pulse\n        this._beforeX = this.currentX;\n        this._beforeY = this.currentY;\n        this.currentX = this.inputX;\n        this.currentY = this.inputY;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSW5wdXQudHM/MzUzZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQztBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL0lucHV0LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDrp4jsmrDsiqQg7J6F66Cl7J2EIOuwm+yVhOuTpOyXrOyEnCDrpqzsiqTrhIjsl5Dqsowg7KCE64us7ZWY64qUIO2BtOuemOyKpFxuICog7J20IO2BtOuemOyKpOuKlCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKeydhCDsgqzsmqntlZwg7JeF642w7J207Yq4IO2MqO2EtOyXkCDtirntmZTrkJwg6rWs7KGw66W8IOqwgOyngOqzoCDsnojri6QuXG4gKiDspJHsmpTtlZjqs6Ag7JaR7J20IOu5hOq1kOyggSDsoIHsnYAg7J2067Kk7Yq4KOuniOyasOyKpCDriITrpoQsIOuniOyasOyKpCDrhpPsnYwp64qUIOunpCDsnbTrsqTtirgg66Oo7ZSE66eI64ukIOuGk+y5mOyngCDslYrqs6Ag7Lqh7LOQ7ZW0IOuRkOqzoCwg7JWV64+E7KCB7Jy866GcIOunjuydtCDrsJzsg53tlZjqs6Ag7KSR7JqU7ZWY7KeAIOyViuydgCDsnbTrsqTtirgo66eI7Jqw7IqkIOybgOyngeyehCnripQg67OA7ZmU7JeQIOuUsOudvCBcIu2YhOyerCDsg4Htg5xcIuyZgCBcIuyngeyghCDsg4Htg5xcIuunjOydhCDsoIDsnqXtlbQg65GQ6rOgIHJBRuyXkOyEnCDqt7gg7IOB7YOc66W8IOywuOyhsO2VmOuPhOuhnSDtlZjqs6Ag7J6I64ukLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3VzZUlucHV0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIOykkeyalCDsnbTrsqTtirgo66eI7Jqw7IqkIOuIhOumhCwg66eI7Jqw7IqkIOuGk+ydjCnrpbwg7KCA7J6l7ZWcIO2BkCAqL1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBET00g7J2067Kk7Yq46rCAIOuwnOyDne2WiOydhCDrlYwg7J6E7Iuc7KCB7Jy866GcIOy6oeyzkO2VnCDrp4jsmrDsiqQg7JyE7LmYXG4gICAgICAgICAqIOydtOqyg+ydgCDsnbTrj5ksIOuIhOumhCwg64aT7J2MIOuqqOuToCDsooXrpZjsnZgg7J2067Kk7Yq466W8IOuwm+yVhOuTpOyduOuLpFxuICAgICAgICAgKiBMaXN0ZW5lcuqwgCDrp4jsmrDsiqQg7KKM7ZGc66W8IOuwm+yVhOuTpOydtOuptCDtjbzsppAg7KGw6rCB7JeQIOuwlOuhnCDrsJjsmIHtlZjsp4Ag7JWK6rOgLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWXsnbQg64+M7JWE7JisIOuVjOq5jOyngCDquLDri6TrprDri6QuICjsnbTrsqTtirgg7ZW465Ok66eB7J20IHJBRuuztOuLpCDtm6jslKwg66eO7J20IOuwnOyDne2VnOuLpC4pXG4gICAgICAgICAqIOuUsOudvOyEnCDsj5/slYTsp4DripQg7J2067Kk7Yq466GcIOyduO2VtCDrtojtlYTsmpTtlZjqsowg7ISx64ql7J20IOyggO2VmOuQmOuKlCDqsoPsnYQg67Cp7KeA7ZWc64ukLlxuICAgICAgICAgKiDslrTrlqQg7J2067Kk7Yq4IOujqO2UhOyXkOyEnCByQUbqsIAg67Cc7IOd7ZWY7KeAIOyViuycvOuptCDtlbTri7kg66Oo7ZSE66GcIOuwm+yVhOuTpOyduCDsooztkZzripQg67KE66Ck7KeA6rKMIOuQnOuLpC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5pbnB1dFggPSBudWxsO1xuICAgICAgICB0aGlzLmlucHV0WSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbnB1dFgsIGlucHV0WeuKlCDrk5zrnpjqt7jrpbwg7ZWY64qUIO2VnOyXkOyEnOuKlCDtmITsnqwg7JyE7LmY66GcIOyCrOyaqeuQoCDsiJgg7J6I7Jy864KYLFxuICAgICAgICAgKiDrk5zrnpjqt7jrpbwg7ZWY7KeAIOyViuuKlCDrj5nslYjsl5DripQg66eI7KeA66eJ7Jy866GcIOuniOyasOyKpCDsnbTrsqTtirjqsIAg7J287Ja064KcIOyngOygkOydtCDqs4Tsho0g7KCA7J6l65CY7Ja0IOyeiOuLpC5cbiAgICAgICAgICog6rKM64uk6rCAIHVwZGF0ZSgp7JeQ7IScIGRpc3BhdGNo7JmAIHB1bHNl64qUIOuniOyasOyKpCDriIzrprwg7Jes67aA7JmAIOq0gOqzhOyXhuydtCDtla3sg4Eg7Iuk7ZaJ65Cc64ukLlxuICAgICAgICAgKiDrlLDrnbzshJwgaW5wdXRYLCBpbnB1dFnripQgXCLtmITsnqxcIuulvCDrgpjtg4DrgrTquLDsl5DripQg67aA7KCB7KCI7ZWY64ukLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRYID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50WSA9IG51bGw7XG4gICAgICAgIC8qKiAocHJpdmF0ZSkg66eI7KeA66eJIHVwZGF0ZShyQUYp6rCAIOuwnOyDne2VmOq4sCDsp4HsoITsnZgg66eI7Jqw7IqkIOychOy5mCAqL1xuICAgICAgICB0aGlzLl9iZWZvcmVYID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmVmb3JlWSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDrp4jsmrDsiqQg64iE66aEIOuwnOyDnSDsi5wsIOyWuOygoOqwgCDrsJzsg53tlaAg66eI7Jqw7IqkIOuWvOq4sOyXkCDrjIDsnZHtlZjsl6wg7J6E7Iuc66GcIOuplOyLnOyngOulvCDrp4zrk6TslrQg7KCA7J6l7ZW0IOuRmCDrsLDsl7RcbiAgICAgICAgICogbWVzc2FnZVBvb2xbbl3snYAgbuuyiCDrp4jsmrDsiqQg67KE7Yq8IOuIhOumhOyXkCDrjIDsnZHtlZjripQg7J6E7IucIOuniOyasOyKpCDrlrzquLAg66mU7Iuc7KeA7J2064ukLlxuICAgICAgICAgKiBu67KIIOuniOyasOyKpCDrsoTtirwg65a86riw6rCAIOuwnOyDne2VmOuptCBtZXNzYWdlUG9vbFtuXeyXkCDsnojripQg66mU7Iuc7KeA66W8IOq6vOuCtOyEnCBlbmQg6rCS7J2EIOyeheugpe2VmOqzoCDtgZDsl5Ag64Sj64qU64ukLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLm1lc3NhZ2VQb29sID0gW107XG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gQHRvZG8gOiBhY2NlcHRDb29yZGluYXRl65WM66y47JeQIGxpc3RlbmVy6rCAIOuLqCDtlZjrgpjsnbTslrTslbwg7ZWc64uk64qUIOygnOyVveydtCDstpTqsIDrkJjsl4jri6RcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyLmFjY2VwdENvb3JkaW5hdGUoZXYub2Zmc2V0WCwgZXYub2Zmc2V0WSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhldi5vZmZzZXRYKTtcbiAgICAgICAgICAgICAgICAvLyBwdWxzZeulvCDrp57snLzrqbQgY3VycmVudFjripQgYmVmb3JlWOqwgCDrkJzri6QuXG4gICAgICAgICAgICAgICAgLy8g65Sw65287IScIHJBRuqwgCDrsJzsg53tlZjripQg7Iuc7KCQ7JeQ7IScIOydtOyghCDsnITsuZjripQg66eI7Jqw7IqkIOuIhOumhCDsnITsuZjroZwg6rCE7KO865Cc64ukLlxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFggPSBldi5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFkgPSBldi5vZmZzZXRZO1xuICAgICAgICAgICAgICAgIC8vIOydtOqyg+qzvCByQUYg7IKs7J207JeQIG1vdmXqsIAg67Cc7IOd7ZWY7KeAIOyViuycvOuptCByQUYg67Cc7IOdIOyLnCDtmIDsnqwg7JyE7LmYIOuYkO2VnCDrp4jsmrDsiqQg64iE66aEIOychOy5mOqwgCDrkJzri6QuXG4gICAgICAgICAgICAgICAgLy8gckFGIOuwnOyDnSDsoITsl5AgbW92ZeqwgCDrqLzsoIAg67Cc7IOd7ZWY66m0IGlucHV06rCS7J2EIOuNruyWtOyNqOyEnCDqsZTrk6TsnbQgY3VycmVudOqwkuydtCDrkJjqsqDsp4A/XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFggPSBldi5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRZID0gZXYub2Zmc2V0WTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XG4gICAgICAgICAgICAgICAgLy8g66eI7Jqw7IqkIOuIhOumhCDsnbTrsqTtirjrpbwg7J6F66Cl7ZWc64ukLlxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibW91c2Vkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGV2Lm9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2Lm9mZnNldFksXG4gICAgICAgICAgICAgICAgICAgIHQ6IGV2LnRpbWVTdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRYOiBldi5vZmZzZXRYLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFk6IGV2Lm9mZnNldFksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogZXYudGltZVN0YW1wXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZG93bi11cCBwYWly66W8IOychO2VtCDrp4jsmrDsiqQg64iE66aEIOychOy5mOulvCDsoIDsnqXtlZzri6QuXG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlUG9vbFtldi5idXR0b25dID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm1vdXNldXBcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRYOiBldi5vZmZzZXRYLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFk6IGV2Lm9mZnNldFksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogZXYudGltZVN0YW1wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb3VzZW1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRYID0gZXYub2Zmc2V0WDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRZID0gZXYub2Zmc2V0WTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb3VzZXVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAvKiBNb3VzZUV2ZW50Lm9mZnNldFjripQgc291cmNlIOyDgeuMgCDsnITsuZjsnbTri6QuIOudoOyaqSEgKi9cbiAgICAgICAgICAgIGxldCB4ID0gZXYub2Zmc2V0WDtcbiAgICAgICAgICAgIGxldCB5ID0gZXYub2Zmc2V0WTtcbiAgICAgICAgICAgIC8vIOuniOyasOyKpCDriITrpoQg64u57IucIOyggOyepe2WiOuNmCDrp4jsmrDsiqQg64aT6riwIOuplOyLnOyngOulvCDqsIDsoLjsmKjri6QuXG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMubWVzc2FnZVBvb2xbZXYuYnV0dG9uXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1lc3NhZ2VQb29sW2V2LmJ1dHRvbl07XG4gICAgICAgICAgICAvLyDruYTroZzshowg66eI7Jqw7IqkIOuWvOq4sCDsoJXrs7Trpbwg7Ja77JeI7Jy864uIIOq3uCDsoJXrs7Trpbwg7J6F66Cl7ZWc64ukLlxuICAgICAgICAgICAgbWVzc2FnZS5lbmRYID0geDtcbiAgICAgICAgICAgIG1lc3NhZ2UuZW5kWSA9IHk7XG4gICAgICAgICAgICBtZXNzYWdlLmVuZFRpbWUgPSBldi50aW1lU3RhbXA7XG4gICAgICAgICAgICAvLyDrqZTsi5zsp4Drpbwg7J6F66Cl7ZWc64ukLlxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8g7ZiE7J6sIHJBRuydmCDrp4jsmrDsiqQg7JyE7LmY66W8IOuWvOq4sCDsnITsuZjroZwg6rCE7KO87ZWc64ukLlxuICAgICAgICAgICAgLy8gaW5wdXTsl5Dri6Qg7KKM7ZGc66W8IOuEo+yWtOuRkOuptCByQUYg67Cc7IOdIOyLnCBjdXJyZW5066GcIOuCtOugpOqwgOqyoOyngD9cbiAgICAgICAgICAgIHRoaXMuaW5wdXRYID0geDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRZID0geTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNldXApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiog7ZiE7J6sIOuniOyasOyKpCDsnITsuZggKi9cbiAgICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuY3VycmVudFg7IH1cbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuY3VycmVudFk7IH1cbiAgICAvKiog66eI7KeA66eJIHVwZGF0ZShyQUYp6rCAIOuwnOyDne2VmOq4sCDsp4HsoITsnZgg66eI7Jqw7IqkIOychOy5mCAqL1xuICAgIGdldCBiZWZvcmVYKCkgeyByZXR1cm4gdGhpcy5fYmVmb3JlWDsgfVxuICAgIGdldCBiZWZvcmVZKCkgeyByZXR1cm4gdGhpcy5fYmVmb3JlWTsgfVxuICAgIC8qKiB1cGRhdGUockFGKSDqsITsnZggeCwgeSDrs4DtmZTrn4kgKi9cbiAgICBnZXQgbW92ZVgoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iZWZvcmVYICE9IG51bGwpICYmICh0aGlzLmN1cnJlbnRYICE9IG51bGwpID8gKHRoaXMuY3VycmVudFggLSB0aGlzLl9iZWZvcmVYKSA6IDA7XG4gICAgfVxuICAgIGdldCBtb3ZlWSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJlZm9yZVkgIT0gbnVsbCkgJiYgKHRoaXMuY3VycmVudFkgIT0gbnVsbCkgPyAodGhpcy5jdXJyZW50WSAtIHRoaXMuX2JlZm9yZVkpIDogMDtcbiAgICB9XG4gICAgLyoqIOyeheugpSDsu7Ttj6zrhIztirjrpbwg67ew7JeQIOyXsOqysO2VnOuLpC4gKi9cbiAgICBjb25uZWN0KHNvdXJjZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duKTtcbiAgICB9XG4gICAgLyoqIOyeheugpSDsu7Ttj6zrhIztirgg7Jew6rKw7J2EIO2VtOygnO2VnOuLpC4gKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bik7XG4gICAgICAgICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogKHJBRikg7YGQ7JeQIOyeiOuKlCDrqZTsi5zsp4Drpbwg66qo65GQIOygleumrO2VmOqzoCwg7IOB7YOc66W8IOyghOydtOyLnO2CqOuLpC5cbiAgICAgKlxuICAgICAqICMg7KSR7JqUIDog65SU7Iqk7Yyo7LmY64qUIGN1cnJlbnRYfFksIGJlZm9yZVh8WSwgbW92ZVh8WeyZgOuKlCDsoobrj4Qg7IOB6rSAIOyXhuuLpOqzoCDslKjrsJzrhojslYQhIVxuICAgICAqICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyBkaXNwYXRjaFxuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgd2hpbGUgKChtZXNzYWdlID0gdGhpcy5tZXNzYWdlcy5zaGlmdCgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5kaXNwYXRjaE1vdXNlZG93bihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5kaXNwYXRjaE1vdXNldXAobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHB1bHNlXG4gICAgICAgIHRoaXMuX2JlZm9yZVggPSB0aGlzLmN1cnJlbnRYO1xuICAgICAgICB0aGlzLl9iZWZvcmVZID0gdGhpcy5jdXJyZW50WTtcbiAgICAgICAgdGhpcy5jdXJyZW50WCA9IHRoaXMuaW5wdXRYO1xuICAgICAgICB0aGlzLmN1cnJlbnRZID0gdGhpcy5pbnB1dFk7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Input.ts\n");

/***/ }),

/***/ "./src/Piece.ts":
/*!**********************!*\
  !*** ./src/Piece.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Piece; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\nconst AXIS = {\n    h: {\n        axis: 'x',\n        start: 'left',\n        end: 'right'\n    },\n    v: {\n        axis: 'y',\n        start: 'top',\n        end: 'bottom'\n    }\n};\nclass Piece {\n    constructor(tag, texture, srcX, srcY, srcD, viewD) {\n        /** 퍼즐 조각이 혼자서 움직일 때 (마우스를 놓을 때) 퍼즐 조각이 이동하는 경로 */\n        this.destX = null;\n        this.destY = null;\n        /** 퍼즐 조각의 이동 속도 (업데이트에 이용된다. 아님 말고.) */\n        this.velX = 0;\n        this.velY = 0;\n        this.tag = tag;\n        this.texture = texture;\n        this.sx = srcX;\n        this.sy = srcY;\n        this.srcSize = srcD;\n        this.size = viewD;\n    }\n    /** 퍼즐 조각의 목표 위치/현재 위치를 기반으로 퍼즐의 행렬 위치를 찾아낸다. */\n    whereami(left, top, boardSize, divideBy) {\n        let x = (this.destX != null ? this.destX : this.x) + this.size / 2;\n        let y = (this.destY != null ? this.destY : this.y) + this.size / 2;\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getRowCol\"])(x, y, boardSize, left, top, divideBy);\n    }\n    /** 퍼즐 조각을 한 방향으로 움직인다. (대각선 이동은 구현에 좀 더 정교한 기하학을 필요로 한다.) 다른 퍼즐 조각과 부딪히는 경우 그것도 함께 밀어낸다. 이것은 **한 업데이트 사이클에서 모두 일어난다!** */\n    push(dist, direction, game, concern) {\n        const { axis, start, end } = AXIS[direction];\n        let backpress = null;\n        let est = this[axis] + dist;\n        if (est < game[start]) {\n            backpress = est - game[start];\n            est = game[start];\n        }\n        else if (est + this.size > game[end]) {\n            backpress = est + this.size - game[end];\n            est = game[end] - this.size;\n        }\n        this[axis] = est;\n        if (backpress)\n            return backpress;\n        for (const piece of concern) {\n            if (Piece.hitTest(this, piece, game.blankTag)) {\n                let dist_ = (this.size * Math.sign(dist) + this[axis] - piece[axis]);\n                backpress = piece.push(dist_, direction, game, concern);\n                if (backpress != null) {\n                    this[axis] -= backpress;\n                    return backpress;\n                }\n            }\n        }\n        return backpress;\n    }\n    /**\n     * 퍼즐 조각을 한 방향으로 움직이기만 한다.\n     * 위에 것과는 다르게 재귀를 사용하지 않는다.\n     */\n    move(dist, direction, game, concern) {\n        const { axis, start, end } = AXIS[direction];\n    }\n    /**\n     * 업데이트한다.\n     * 빈칸을 나타내는 조각은 업데이트되지 않는다.\n     *\n     * 일단, 업데이트 자체는 드래그 여부와 상관없이 모든 조각에 대해 항상 실행된다.\n    */\n    update(game) {\n        // (참고 : 마우스 버튼을 누르는 순간 모든 조각의 destX, destY가 null이 되고 velX, velY 또한 0이 되므로 조각을 드래그하는 중에는 이 블록과 저 아래에 destY 블록까지 무시된다.)\n        // 아직 목표 x위치에 도달하지 않았다면\n        if (this.destX != null) {\n            let distX = this.destX - this.x;\n            // 목표 위치에 도달할 수 있도록 속도를 설정해준다.\n            this.velX = this.size / 6 * Math.sign(distX);\n            // 조각이 목표에 충분히 가까이 접근했다면 목표 위치에 안착시키고, 속도를 없앤다.\n            if ((Math.abs(distX) < Math.abs(this.velX)) || (Math.abs(distX) < 0.1)) {\n                this.x = this.destX;\n                this.destX = null;\n                if (Math.abs(this.velX) >= 3) {\n                    // tick!\n                }\n                this.velX = 0;\n            }\n        }\n        if (this.destY != null) {\n            let distY = this.destY - this.y;\n            this.velY = this.size / 6 * Math.sign(distY);\n            if ((Math.abs(distY) < Math.abs(this.velY)) || (Math.abs(distY) < 0.1)) {\n                this.y = this.destY;\n                this.destY = null;\n                if (Math.abs(this.velY) >= 3) {\n                    // tick!\n                }\n                this.velY = 0;\n            }\n        }\n        this.x += this.velX;\n        this.y += this.velY;\n        if (this.x < game.left) {\n            this.x = game.left;\n            this.velX = 0;\n        }\n        else if (this.x + this.size > game.right) {\n            this.x = game.right - this.size;\n            this.velX = 0;\n        }\n        if (this.y < game.top) {\n            this.y = game.top;\n            this.velY = 0;\n        }\n        else if (this.y + this.size > game.bottom) {\n            this.y = game.bottom - this.size;\n            this.velY = 0;\n        }\n    }\n    /**\n     * 렌더링한다.\n     * 빈칸을 나타내는 조각에 대해서는 메서드가 아예 실행되지 않는다.\n     */\n    render(context, showLabel = true) {\n        context.fillStyle = 'white';\n        context.lineWidth = 1;\n        context.strokeRect(this.x, this.y, this.size, this.size);\n        context.fillRect(this.x, this.y, this.size, this.size);\n        context.drawImage(this.texture, this.sx, this.sy, this.srcSize, this.srcSize, this.x, this.y, this.size, this.size);\n        if (showLabel) {\n            let fontSize = Math.floor(this.size / 3);\n            context.font = fontSize + 'px \"Exo 2\"';\n            context.lineWidth = 3;\n            let { width } = context.measureText(this.label);\n            let x = this.x + width / 2 + 4;\n            let y = this.y + this.size / 6 + 2;\n            context.strokeText(this.label, x, y);\n            context.fillText(this.label, x, y);\n        }\n    }\n    /**\n     * 퍼즐 조각을 목표 위치로 즉시 이동시키고, 속도를 없앤다.\n     */\n    getIntoPositionNow() {\n        if (this.destX != null) {\n            this.x = this.destX;\n            this.destX = null;\n            this.velX = 0;\n        }\n        if (this.destY != null) {\n            this.y = this.destY;\n            this.destY = null;\n            this.velY = 0;\n        }\n    }\n    /** x에서 x + velX로 또는 y에서 y + velY로 이동하는 경로에 부딪힐 다른 조각들이 있는지 판단한다. */\n    willHit(concern, direction) {\n        let vector = [];\n        if (direction == \"h\") {\n            for (const piece of concern) {\n                // if (piece.x + piece.size )\n            }\n        }\n        else if (direction == \"v\") {\n        }\n        return vector;\n    }\n    static hitTest(a, b, blankTag) {\n        if (a == b || a.tag == blankTag || b.tag == blankTag)\n            return false;\n        let leftA = a.x;\n        let rightA = a.x + a.size;\n        let topA = a.y;\n        let bottomA = a.y + a.size;\n        let leftB = b.x;\n        let rightB = b.x + b.size;\n        let topB = b.y;\n        let bottomB = b.y + b.size;\n        return leftA < rightB && leftB < rightA && topA < bottomB && topB < bottomA;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUGllY2UudHM/NTE3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9QaWVjZS50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFJvd0NvbCB9IGZyb20gXCIuL3V0aWxzXCI7XG5jb25zdCBBWElTID0ge1xuICAgIGg6IHtcbiAgICAgICAgYXhpczogJ3gnLFxuICAgICAgICBzdGFydDogJ2xlZnQnLFxuICAgICAgICBlbmQ6ICdyaWdodCdcbiAgICB9LFxuICAgIHY6IHtcbiAgICAgICAgYXhpczogJ3knLFxuICAgICAgICBzdGFydDogJ3RvcCcsXG4gICAgICAgIGVuZDogJ2JvdHRvbSdcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGllY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgdGV4dHVyZSwgc3JjWCwgc3JjWSwgc3JjRCwgdmlld0QpIHtcbiAgICAgICAgLyoqIO2NvOymkCDsobDqsIHsnbQg7Zi87J6Q7IScIOybgOyngeydvCDrlYwgKOuniOyasOyKpOulvCDrhpPsnYQg65WMKSDtjbzsppAg7KGw6rCB7J20IOydtOuPme2VmOuKlCDqsr3roZwgKi9cbiAgICAgICAgdGhpcy5kZXN0WCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVzdFkgPSBudWxsO1xuICAgICAgICAvKiog7Y287KaQIOyhsOqwgeydmCDsnbTrj5kg7IaN64+EICjsl4XrjbDsnbTtirjsl5Ag7J207Jqp65Cc64ukLiDslYTri5gg66eQ6rOgLikgKi9cbiAgICAgICAgdGhpcy52ZWxYID0gMDtcbiAgICAgICAgdGhpcy52ZWxZID0gMDtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgIHRoaXMuc3ggPSBzcmNYO1xuICAgICAgICB0aGlzLnN5ID0gc3JjWTtcbiAgICAgICAgdGhpcy5zcmNTaXplID0gc3JjRDtcbiAgICAgICAgdGhpcy5zaXplID0gdmlld0Q7XG4gICAgfVxuICAgIC8qKiDtjbzsppAg7KGw6rCB7J2YIOuqqe2RnCDsnITsuZgv7ZiE7J6sIOychOy5mOulvCDquLDrsJjsnLzroZwg7Y287KaQ7J2YIO2WieugrCDsnITsuZjrpbwg7LC+7JWE64K464ukLiAqL1xuICAgIHdoZXJlYW1pKGxlZnQsIHRvcCwgYm9hcmRTaXplLCBkaXZpZGVCeSkge1xuICAgICAgICBsZXQgeCA9ICh0aGlzLmRlc3RYICE9IG51bGwgPyB0aGlzLmRlc3RYIDogdGhpcy54KSArIHRoaXMuc2l6ZSAvIDI7XG4gICAgICAgIGxldCB5ID0gKHRoaXMuZGVzdFkgIT0gbnVsbCA/IHRoaXMuZGVzdFkgOiB0aGlzLnkpICsgdGhpcy5zaXplIC8gMjtcbiAgICAgICAgcmV0dXJuIGdldFJvd0NvbCh4LCB5LCBib2FyZFNpemUsIGxlZnQsIHRvcCwgZGl2aWRlQnkpO1xuICAgIH1cbiAgICAvKiog7Y287KaQIOyhsOqwgeydhCDtlZwg67Cp7Zal7Jy866GcIOybgOyngeyduOuLpC4gKOuMgOqwgeyEoCDsnbTrj5nsnYAg6rWs7ZiE7JeQIOyigCDrjZQg7KCV6rWQ7ZWcIOq4sO2VmO2VmeydhCDtlYTsmpTroZwg7ZWc64ukLikg64uk66W4IO2NvOymkCDsobDqsIHqs7wg67aA65Sq7Z6I64qUIOqyveyasCDqt7jqsoPrj4Qg7ZWo6ruYIOuwgOyWtOuCuOuLpC4g7J206rKD7J2AICoq7ZWcIOyXheuNsOydtO2KuCDsgqzsnbTtgbTsl5DshJwg66qo65GQIOydvOyWtOuCnOuLpCEqKiAqL1xuICAgIHB1c2goZGlzdCwgZGlyZWN0aW9uLCBnYW1lLCBjb25jZXJuKSB7XG4gICAgICAgIGNvbnN0IHsgYXhpcywgc3RhcnQsIGVuZCB9ID0gQVhJU1tkaXJlY3Rpb25dO1xuICAgICAgICBsZXQgYmFja3ByZXNzID0gbnVsbDtcbiAgICAgICAgbGV0IGVzdCA9IHRoaXNbYXhpc10gKyBkaXN0O1xuICAgICAgICBpZiAoZXN0IDwgZ2FtZVtzdGFydF0pIHtcbiAgICAgICAgICAgIGJhY2twcmVzcyA9IGVzdCAtIGdhbWVbc3RhcnRdO1xuICAgICAgICAgICAgZXN0ID0gZ2FtZVtzdGFydF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXN0ICsgdGhpcy5zaXplID4gZ2FtZVtlbmRdKSB7XG4gICAgICAgICAgICBiYWNrcHJlc3MgPSBlc3QgKyB0aGlzLnNpemUgLSBnYW1lW2VuZF07XG4gICAgICAgICAgICBlc3QgPSBnYW1lW2VuZF0gLSB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1theGlzXSA9IGVzdDtcbiAgICAgICAgaWYgKGJhY2twcmVzcylcbiAgICAgICAgICAgIHJldHVybiBiYWNrcHJlc3M7XG4gICAgICAgIGZvciAoY29uc3QgcGllY2Ugb2YgY29uY2Vybikge1xuICAgICAgICAgICAgaWYgKFBpZWNlLmhpdFRlc3QodGhpcywgcGllY2UsIGdhbWUuYmxhbmtUYWcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3RfID0gKHRoaXMuc2l6ZSAqIE1hdGguc2lnbihkaXN0KSArIHRoaXNbYXhpc10gLSBwaWVjZVtheGlzXSk7XG4gICAgICAgICAgICAgICAgYmFja3ByZXNzID0gcGllY2UucHVzaChkaXN0XywgZGlyZWN0aW9uLCBnYW1lLCBjb25jZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFja3ByZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1theGlzXSAtPSBiYWNrcHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYWNrcHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYWNrcHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIO2NvOymkCDsobDqsIHsnYQg7ZWcIOuwqe2WpeycvOuhnCDsm4Dsp4HsnbTquLDrp4wg7ZWc64ukLlxuICAgICAqIOychOyXkCDqsoPqs7zripQg64uk66W06rKMIOyerOq3gOulvCDsgqzsmqntlZjsp4Ag7JWK64qU64ukLlxuICAgICAqL1xuICAgIG1vdmUoZGlzdCwgZGlyZWN0aW9uLCBnYW1lLCBjb25jZXJuKSB7XG4gICAgICAgIGNvbnN0IHsgYXhpcywgc3RhcnQsIGVuZCB9ID0gQVhJU1tkaXJlY3Rpb25dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDsl4XrjbDsnbTtirjtlZzri6QuXG4gICAgICog67mI7Lm47J2EIOuCmO2DgOuCtOuKlCDsobDqsIHsnYAg7JeF642w7J207Yq465CY7KeAIOyViuuKlOuLpC5cbiAgICAgKlxuICAgICAqIOydvOuLqCwg7JeF642w7J207Yq4IOyekOyytOuKlCDrk5zrnpjqt7gg7Jes67aA7JmAIOyDgeq0gOyXhuydtCDrqqjrk6Ag7KGw6rCB7JeQIOuMgO2VtCDtla3sg4Eg7Iuk7ZaJ65Cc64ukLlxuICAgICovXG4gICAgdXBkYXRlKGdhbWUpIHtcbiAgICAgICAgLy8gKOywuOqzoCA6IOuniOyasOyKpCDrsoTtirzsnYQg64iE66W064qUIOyInOqwhCDrqqjrk6Ag7KGw6rCB7J2YIGRlc3RYLCBkZXN0WeqwgCBudWxs7J20IOuQmOqzoCB2ZWxYLCB2ZWxZIOuYkO2VnCAw7J20IOuQmOuvgOuhnCDsobDqsIHsnYQg65Oc656Y6re47ZWY64qUIOykkeyXkOuKlCDsnbQg67iU66Gd6rO8IOyggCDslYTrnpjsl5AgZGVzdFkg67iU66Gd6rmM7KeAIOustOyLnOuQnOuLpC4pXG4gICAgICAgIC8vIOyVhOyngSDrqqntkZwgeOychOy5mOyXkCDrj4Tri6ztlZjsp4Ag7JWK7JWY64uk66m0XG4gICAgICAgIGlmICh0aGlzLmRlc3RYICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkaXN0WCA9IHRoaXMuZGVzdFggLSB0aGlzLng7XG4gICAgICAgICAgICAvLyDrqqntkZwg7JyE7LmY7JeQIOuPhOuLrO2VoCDsiJgg7J6I64+E66GdIOyGjeuPhOulvCDshKTsoJXtlbTspIDri6QuXG4gICAgICAgICAgICB0aGlzLnZlbFggPSB0aGlzLnNpemUgLyA2ICogTWF0aC5zaWduKGRpc3RYKTtcbiAgICAgICAgICAgIC8vIOyhsOqwgeydtCDrqqntkZzsl5Ag7Lap67aE7Z6IIOqwgOq5jOydtCDsoJHqt7ztlojri6TrqbQg66qp7ZGcIOychOy5mOyXkCDslYjssKnsi5ztgqTqs6AsIOyGjeuPhOulvCDsl4bslaTri6QuXG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKGRpc3RYKSA8IE1hdGguYWJzKHRoaXMudmVsWCkpIHx8IChNYXRoLmFicyhkaXN0WCkgPCAwLjEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5kZXN0WDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RYID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxYKSA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRpY2shXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmVsWCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVzdFkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGRpc3RZID0gdGhpcy5kZXN0WSAtIHRoaXMueTtcbiAgICAgICAgICAgIHRoaXMudmVsWSA9IHRoaXMuc2l6ZSAvIDYgKiBNYXRoLnNpZ24oZGlzdFkpO1xuICAgICAgICAgICAgaWYgKChNYXRoLmFicyhkaXN0WSkgPCBNYXRoLmFicyh0aGlzLnZlbFkpKSB8fCAoTWF0aC5hYnMoZGlzdFkpIDwgMC4xKSkge1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuZGVzdFk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0WSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMudmVsWSkgPj0gMykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aWNrIVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZlbFkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMueCArPSB0aGlzLnZlbFg7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XG4gICAgICAgIGlmICh0aGlzLnggPCBnYW1lLmxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IGdhbWUubGVmdDtcbiAgICAgICAgICAgIHRoaXMudmVsWCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54ICsgdGhpcy5zaXplID4gZ2FtZS5yaWdodCkge1xuICAgICAgICAgICAgdGhpcy54ID0gZ2FtZS5yaWdodCAtIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudmVsWCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMueSA8IGdhbWUudG9wKSB7XG4gICAgICAgICAgICB0aGlzLnkgPSBnYW1lLnRvcDtcbiAgICAgICAgICAgIHRoaXMudmVsWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy55ICsgdGhpcy5zaXplID4gZ2FtZS5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMueSA9IGdhbWUuYm90dG9tIC0gdGhpcy5zaXplO1xuICAgICAgICAgICAgdGhpcy52ZWxZID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDroIzrjZTrp4HtlZzri6QuXG4gICAgICog67mI7Lm47J2EIOuCmO2DgOuCtOuKlCDsobDqsIHsl5Ag64yA7ZW07ISc64qUIOuplOyEnOuTnOqwgCDslYTsmIgg7Iuk7ZaJ65CY7KeAIOyViuuKlOuLpC5cbiAgICAgKi9cbiAgICByZW5kZXIoY29udGV4dCwgc2hvd0xhYmVsID0gdHJ1ZSkge1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnN4LCB0aGlzLnN5LCB0aGlzLnNyY1NpemUsIHRoaXMuc3JjU2l6ZSwgdGhpcy54LCB0aGlzLnksIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcbiAgICAgICAgaWYgKHNob3dMYWJlbCkge1xuICAgICAgICAgICAgbGV0IGZvbnRTaXplID0gTWF0aC5mbG9vcih0aGlzLnNpemUgLyAzKTtcbiAgICAgICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTaXplICsgJ3B4IFwiRXhvIDJcIic7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDM7XG4gICAgICAgICAgICBsZXQgeyB3aWR0aCB9ID0gY29udGV4dC5tZWFzdXJlVGV4dCh0aGlzLmxhYmVsKTtcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy54ICsgd2lkdGggLyAyICsgNDtcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy55ICsgdGhpcy5zaXplIC8gNiArIDI7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5sYWJlbCwgeCwgeSk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMubGFiZWwsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIO2NvOymkCDsobDqsIHsnYQg66qp7ZGcIOychOy5mOuhnCDsponsi5wg7J2064+Z7Iuc7YKk6rOgLCDsho3rj4Trpbwg7JeG7JWk64ukLlxuICAgICAqL1xuICAgIGdldEludG9Qb3NpdGlvbk5vdygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdFggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5kZXN0WDtcbiAgICAgICAgICAgIHRoaXMuZGVzdFggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52ZWxYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXN0WSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLmRlc3RZO1xuICAgICAgICAgICAgdGhpcy5kZXN0WSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZlbFkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiB47JeQ7IScIHggKyB2ZWxY66GcIOuYkOuKlCB57JeQ7IScIHkgKyB2ZWxZ66GcIOydtOuPme2VmOuKlCDqsr3roZzsl5Ag67aA65Sq7Z6QIOuLpOuluCDsobDqsIHrk6TsnbQg7J6I64qU7KeAIO2MkOuLqO2VnOuLpC4gKi9cbiAgICB3aWxsSGl0KGNvbmNlcm4sIGRpcmVjdGlvbikge1xuICAgICAgICBsZXQgdmVjdG9yID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJoXCIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGllY2Ugb2YgY29uY2Vybikge1xuICAgICAgICAgICAgICAgIC8vIGlmIChwaWVjZS54ICsgcGllY2Uuc2l6ZSApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09IFwidlwiKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG4gICAgc3RhdGljIGhpdFRlc3QoYSwgYiwgYmxhbmtUYWcpIHtcbiAgICAgICAgaWYgKGEgPT0gYiB8fCBhLnRhZyA9PSBibGFua1RhZyB8fCBiLnRhZyA9PSBibGFua1RhZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGxlZnRBID0gYS54O1xuICAgICAgICBsZXQgcmlnaHRBID0gYS54ICsgYS5zaXplO1xuICAgICAgICBsZXQgdG9wQSA9IGEueTtcbiAgICAgICAgbGV0IGJvdHRvbUEgPSBhLnkgKyBhLnNpemU7XG4gICAgICAgIGxldCBsZWZ0QiA9IGIueDtcbiAgICAgICAgbGV0IHJpZ2h0QiA9IGIueCArIGIuc2l6ZTtcbiAgICAgICAgbGV0IHRvcEIgPSBiLnk7XG4gICAgICAgIGxldCBib3R0b21CID0gYi55ICsgYi5zaXplO1xuICAgICAgICByZXR1cm4gbGVmdEEgPCByaWdodEIgJiYgbGVmdEIgPCByaWdodEEgJiYgdG9wQSA8IGJvdHRvbUIgJiYgdG9wQiA8IGJvdHRvbUE7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Piece.ts\n");

/***/ }),

/***/ "./src/PuzzleSet.ts":
/*!**************************!*\
  !*** ./src/PuzzleSet.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PuzzleSet; });\n/**\n * PuzzleSet은 그림, 정사각형 영역, 해결 가능 여부를 모아놓은 것이다.\n * 행이나 열을 뒤집는 기능 따위는 없다.\n */\nclass PuzzleSet {\n    /**\n     * 행, 열 번호로 이미지에서 참조할 좌표를 찾는다.\n     */\n    getPosition(row, col, divideBy) {\n        let d = this.size / divideBy;\n        return [this.left + col * d, this.top + row * d];\n    }\n    waitForImageLoad() {\n        this.texture = new Image();\n        this.texture.src = '/img/' + this.img;\n        if (this.texture.complete) {\n            return Promise.resolve();\n        }\n        return new Promise((a, b) => {\n            this.texture.onload = ev => {\n                a();\n            };\n            this.texture.onerror = b;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUHV6emxlU2V0LnRzP2VmMjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsImZpbGUiOiIuL3NyYy9QdXp6bGVTZXQudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFB1enpsZVNldOydgCDqt7jrprwsIOygleyCrOqwge2YlSDsmIHsl60sIO2VtOqysCDqsIDriqUg7Jes67aA66W8IOuqqOyVhOuGk+ydgCDqsoPsnbTri6QuXG4gKiDtlonsnbTrgpgg7Je07J2EIOuSpOynkeuKlCDquLDriqUg65Sw7JyE64qUIOyXhuuLpC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHV6emxlU2V0IHtcbiAgICAvKipcbiAgICAgKiDtloksIOyXtCDrsojtmLjroZwg7J2066+47KeA7JeQ7IScIOywuOyhsO2VoCDsooztkZzrpbwg7LC+64qU64ukLlxuICAgICAqL1xuICAgIGdldFBvc2l0aW9uKHJvdywgY29sLCBkaXZpZGVCeSkge1xuICAgICAgICBsZXQgZCA9IHRoaXMuc2l6ZSAvIGRpdmlkZUJ5O1xuICAgICAgICByZXR1cm4gW3RoaXMubGVmdCArIGNvbCAqIGQsIHRoaXMudG9wICsgcm93ICogZF07XG4gICAgfVxuICAgIHdhaXRGb3JJbWFnZUxvYWQoKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aGlzLnRleHR1cmUuc3JjID0gJy9pbWcvJyArIHRoaXMuaW1nO1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChhLCBiKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUub25sb2FkID0gZXYgPT4ge1xuICAgICAgICAgICAgICAgIGEoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUub25lcnJvciA9IGI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/PuzzleSet.ts\n");

/***/ }),

/***/ "./src/RAFPulseClock.ts":
/*!******************************!*\
  !*** ./src/RAFPulseClock.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RAFPulseClock; });\nclass RAFPulseClock {\n    constructor(update) {\n        this.running = false;\n        this.a = null;\n        this.update = update;\n    }\n    run() {\n        this.running = true;\n        this.a = (t) => {\n            this.update(t);\n            if (this.running) {\n                requestAnimationFrame(this.a);\n            }\n        };\n        requestAnimationFrame(this.a);\n    }\n    stop() {\n        this.running = false;\n        this.a = null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUkFGUHVsc2VDbG9jay50cz8zY2M2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvUkFGUHVsc2VDbG9jay50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJBRlB1bHNlQ2xvY2sge1xuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG4gICAgfVxuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hID0gKHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYSA9IG51bGw7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/RAFPulseClock.ts\n");

/***/ }),

/***/ "./src/Timer.ts":
/*!**********************!*\
  !*** ./src/Timer.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Timer; });\n/** 마이크로초를 mm : ss . ss 로 나눈다. */\nfunction formatMs(ms) {\n    let val = Math.round(ms / 10);\n    let min = Math.floor(val / 6000);\n    let centisec = val % 6000;\n    let centisec_str = centisec.toString();\n    let centisec_len = centisec_str.length;\n    if (centisec_len < 4) {\n        let a = Array(4 - centisec_len);\n        a.fill('0');\n        centisec_str = a.join('') + centisec_str;\n    }\n    let min_str = min.toString();\n    let min_len = min_str.length;\n    if (min_len < 2) {\n        let a = Array(2 - min_len);\n        a.fill('0');\n        min_str = a.join('') + min_str;\n    }\n    return [min_str, centisec_str.substr(0, 2), centisec_str.substr(2, 2)];\n}\n/**\n * 타이머 컴포넌트\n * DOMHighResTimestamp 때문에 로직이 은근 복잡하다.\n * */\nclass Timer {\n    constructor() {\n        /** 시작 버튼을 누른 시각 */\n        this.startTime = null;\n        /** 퍼즐이 중단된 시각 */\n        this.endTime = null;\n        /** rAF에 의해 입력되는 시각 */\n        this.currentTime = 0;\n    }\n    start(startTime) {\n        this.startTime = startTime;\n        this.endTime = null;\n    }\n    end(endTime) {\n        this.endTime = endTime;\n    }\n    reset() {\n        this.startTime = null;\n        this.endTime = null;\n        this.currentTime = null;\n    }\n    update(t) {\n        this.currentTime = t;\n    }\n    render(context, left, len, y) {\n        context.font = '42px \"Exo 2\"';\n        let [min, sec, cs] = formatMs(this.currentTime - this.startTime);\n        let d = len / 3;\n        let p = len / 8;\n        let q = d * 7 / 8;\n        context.lineWidth = 5;\n        context.strokeText(min, left + p, y);\n        context.fillText(min, left + p, y);\n        context.strokeText('\\'', left + q, y);\n        context.fillText('\\'', left + q, y);\n        context.strokeText(sec, left + d + p, y);\n        context.fillText(sec, left + d + p, y);\n        context.strokeText('\"', left + d + q, y);\n        context.fillText('\"', left + d + q, y);\n        context.strokeText(cs, left + d * 2 + p, y);\n        context.fillText(cs, left + d * 2 + p, y);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVGltZXIudHM/OGJjNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9UaW1lci50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiDrp4jsnbTtgazroZzstIjrpbwgbW0gOiBzcyAuIHNzIOuhnCDrgpjriIjri6QuICovXG5mdW5jdGlvbiBmb3JtYXRNcyhtcykge1xuICAgIGxldCB2YWwgPSBNYXRoLnJvdW5kKG1zIC8gMTApO1xuICAgIGxldCBtaW4gPSBNYXRoLmZsb29yKHZhbCAvIDYwMDApO1xuICAgIGxldCBjZW50aXNlYyA9IHZhbCAlIDYwMDA7XG4gICAgbGV0IGNlbnRpc2VjX3N0ciA9IGNlbnRpc2VjLnRvU3RyaW5nKCk7XG4gICAgbGV0IGNlbnRpc2VjX2xlbiA9IGNlbnRpc2VjX3N0ci5sZW5ndGg7XG4gICAgaWYgKGNlbnRpc2VjX2xlbiA8IDQpIHtcbiAgICAgICAgbGV0IGEgPSBBcnJheSg0IC0gY2VudGlzZWNfbGVuKTtcbiAgICAgICAgYS5maWxsKCcwJyk7XG4gICAgICAgIGNlbnRpc2VjX3N0ciA9IGEuam9pbignJykgKyBjZW50aXNlY19zdHI7XG4gICAgfVxuICAgIGxldCBtaW5fc3RyID0gbWluLnRvU3RyaW5nKCk7XG4gICAgbGV0IG1pbl9sZW4gPSBtaW5fc3RyLmxlbmd0aDtcbiAgICBpZiAobWluX2xlbiA8IDIpIHtcbiAgICAgICAgbGV0IGEgPSBBcnJheSgyIC0gbWluX2xlbik7XG4gICAgICAgIGEuZmlsbCgnMCcpO1xuICAgICAgICBtaW5fc3RyID0gYS5qb2luKCcnKSArIG1pbl9zdHI7XG4gICAgfVxuICAgIHJldHVybiBbbWluX3N0ciwgY2VudGlzZWNfc3RyLnN1YnN0cigwLCAyKSwgY2VudGlzZWNfc3RyLnN1YnN0cigyLCAyKV07XG59XG4vKipcbiAqIO2DgOydtOuouCDsu7Ttj6zrhIztirhcbiAqIERPTUhpZ2hSZXNUaW1lc3RhbXAg65WM66y47JeQIOuhnOyngeydtCDsnYDqt7wg67O17J6h7ZWY64ukLlxuICogKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIOyLnOyekSDrsoTtirzsnYQg64iE66W4IOyLnOqwgSAqL1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIC8qKiDtjbzsppDsnbQg7KSR64uo65CcIOyLnOqwgSAqL1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgICAgICAvKiogckFG7JeQIOydmO2VtCDsnoXroKXrkJjripQg7Iuc6rCBICovXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIH1cbiAgICBzdGFydChzdGFydFRpbWUpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgfVxuICAgIGVuZChlbmRUaW1lKSB7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGUodCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdDtcbiAgICB9XG4gICAgcmVuZGVyKGNvbnRleHQsIGxlZnQsIGxlbiwgeSkge1xuICAgICAgICBjb250ZXh0LmZvbnQgPSAnNDJweCBcIkV4byAyXCInO1xuICAgICAgICBsZXQgW21pbiwgc2VjLCBjc10gPSBmb3JtYXRNcyh0aGlzLmN1cnJlbnRUaW1lIC0gdGhpcy5zdGFydFRpbWUpO1xuICAgICAgICBsZXQgZCA9IGxlbiAvIDM7XG4gICAgICAgIGxldCBwID0gbGVuIC8gODtcbiAgICAgICAgbGV0IHEgPSBkICogNyAvIDg7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gNTtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KG1pbiwgbGVmdCArIHAsIHkpO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KG1pbiwgbGVmdCArIHAsIHkpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoJ1xcJycsIGxlZnQgKyBxLCB5KTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCgnXFwnJywgbGVmdCArIHEsIHkpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoc2VjLCBsZWZ0ICsgZCArIHAsIHkpO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHNlYywgbGVmdCArIGQgKyBwLCB5KTtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCdcIicsIGxlZnQgKyBkICsgcSwgeSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoJ1wiJywgbGVmdCArIGQgKyBxLCB5KTtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGNzLCBsZWZ0ICsgZCAqIDIgKyBwLCB5KTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChjcywgbGVmdCArIGQgKiAyICsgcCwgeSk7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Timer.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _PuzzleSet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PuzzleSet */ \"./src/PuzzleSet.ts\");\n/* harmony import */ var _RAFPulseClock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RAFPulseClock */ \"./src/RAFPulseClock.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game */ \"./src/Game.ts\");\n/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Input */ \"./src/Input.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nlet game;\nlet clock;\nlet input;\nconst canvas = document.getElementsByTagName('canvas')[0];\nconst context = canvas.getContext('2d');\ncontext.textAlign = 'center';\ncontext.textBaseline = 'middle';\nconst sizeInput = document.getElementById('size');\nconst puzzleSelector = document.getElementById('puzzle-selector');\nconst startButton = document.getElementById('start');\nconst blankPositionSelector = {\n    topLeft: document.getElementById('blank-pos-top-left'),\n    topRight: document.getElementById('blank-pos-top-right'),\n    bottomLeft: document.getElementById('blank-pos-bottom-left'),\n    bottomRight: document.getElementById('blank-pos-bottom-right'),\n};\nfunction decodeBlank() {\n    return [\n        blankPositionSelector.bottomLeft.checked || blankPositionSelector.bottomRight.checked,\n        blankPositionSelector.topRight.checked || blankPositionSelector.bottomRight.checked\n    ];\n}\nconst labelSelector = {\n    none: document.getElementById('show-label-none'),\n    phone: document.getElementById('show-label-phone'),\n    keypad: document.getElementById('show-label-keypad')\n};\nfunction loadPuzzleSets() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const puzzleSets = [];\n        const response = yield fetch('puzzleset.json');\n        const puzzleSetDataArray = yield response.json();\n        for (let i = 0; i < puzzleSetDataArray.length; i++) {\n            const puzzleSet = puzzleSetDataArray[i];\n            puzzleSet.__proto__ = _PuzzleSet__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype;\n            puzzleSets.push(puzzleSet);\n            const selectOption = document.createElement('option');\n            selectOption.value = i.toString();\n            selectOption.innerText = puzzleSet.title;\n            puzzleSelector.appendChild(selectOption);\n        }\n        yield Promise.all(puzzleSets.map(v => v.waitForImageLoad()));\n        return puzzleSets;\n    });\n}\nfunction setSizeHandler() {\n    game.setSize(sizeInput.valueAsNumber, ...decodeBlank());\n}\nloadPuzzleSets().then((puzzleSets) => {\n    startButton.addEventListener('click', (ev) => {\n        game.shuffle();\n        game.initPiecePosition();\n        game.start(ev.timeStamp);\n    });\n    blankPositionSelector.topLeft.addEventListener('input', setSizeHandler);\n    blankPositionSelector.topRight.addEventListener('input', setSizeHandler);\n    blankPositionSelector.bottomLeft.addEventListener('input', setSizeHandler);\n    blankPositionSelector.bottomRight.addEventListener('input', setSizeHandler);\n    sizeInput.addEventListener('change', setSizeHandler);\n    puzzleSelector.addEventListener('change', ev => {\n        game.setPuzzleSet(puzzleSets[puzzleSelector.value]);\n    });\n    labelSelector.none.addEventListener('input', ev => {\n        game.showLabel = false;\n    });\n    labelSelector.phone.addEventListener('input', ev => {\n        game.showLabel = true;\n        game.assignLabel(false);\n    });\n    labelSelector.keypad.addEventListener('input', ev => {\n        game.showLabel = true;\n        game.assignLabel(true);\n    });\n    let puzzleSet = puzzleSets[puzzleSelector.value];\n    let size = sizeInput.valueAsNumber;\n    game = new _Game__WEBPACK_IMPORTED_MODULE_2__[\"default\"](size, puzzleSet, 20, 20, 320, labelSelector.keypad.checked);\n    input = new _Input__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n    input.connect(canvas, game);\n    clock = new _RAFPulseClock__WEBPACK_IMPORTED_MODULE_1__[\"default\"](t => {\n        input.update();\n        game.update(t, input);\n        game.render(context);\n    });\n    clock.run();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHM/NzFiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDb0M7QUFDUTtBQUNsQjtBQUNPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0Esa0NBQWtDLGtEQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSw2Q0FBSTtBQUNuQixnQkFBZ0IsOENBQVU7QUFDMUI7QUFDQSxnQkFBZ0Isc0RBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL3NyYy9pbmRleC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IFB1enpsZVNldCBmcm9tICcuL1B1enpsZVNldCc7XG5pbXBvcnQgUkFGUHVsc2VDbG9jayBmcm9tICcuL1JBRlB1bHNlQ2xvY2snO1xuaW1wb3J0IEdhbWUgZnJvbSAnLi9HYW1lJztcbmltcG9ydCBNb3VzZUlucHV0IGZyb20gJy4vSW5wdXQnO1xubGV0IGdhbWU7XG5sZXQgY2xvY2s7XG5sZXQgaW5wdXQ7XG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XG5jb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5jb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbmNvbnN0IHNpemVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaXplJyk7XG5jb25zdCBwdXp6bGVTZWxlY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwdXp6bGUtc2VsZWN0b3InKTtcbmNvbnN0IHN0YXJ0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0Jyk7XG5jb25zdCBibGFua1Bvc2l0aW9uU2VsZWN0b3IgPSB7XG4gICAgdG9wTGVmdDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JsYW5rLXBvcy10b3AtbGVmdCcpLFxuICAgIHRvcFJpZ2h0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmxhbmstcG9zLXRvcC1yaWdodCcpLFxuICAgIGJvdHRvbUxlZnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdibGFuay1wb3MtYm90dG9tLWxlZnQnKSxcbiAgICBib3R0b21SaWdodDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JsYW5rLXBvcy1ib3R0b20tcmlnaHQnKSxcbn07XG5mdW5jdGlvbiBkZWNvZGVCbGFuaygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBibGFua1Bvc2l0aW9uU2VsZWN0b3IuYm90dG9tTGVmdC5jaGVja2VkIHx8IGJsYW5rUG9zaXRpb25TZWxlY3Rvci5ib3R0b21SaWdodC5jaGVja2VkLFxuICAgICAgICBibGFua1Bvc2l0aW9uU2VsZWN0b3IudG9wUmlnaHQuY2hlY2tlZCB8fCBibGFua1Bvc2l0aW9uU2VsZWN0b3IuYm90dG9tUmlnaHQuY2hlY2tlZFxuICAgIF07XG59XG5jb25zdCBsYWJlbFNlbGVjdG9yID0ge1xuICAgIG5vbmU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWxhYmVsLW5vbmUnKSxcbiAgICBwaG9uZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Nob3ctbGFiZWwtcGhvbmUnKSxcbiAgICBrZXlwYWQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWxhYmVsLWtleXBhZCcpXG59O1xuZnVuY3Rpb24gbG9hZFB1enpsZVNldHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcHV6emxlU2V0cyA9IFtdO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKCdwdXp6bGVzZXQuanNvbicpO1xuICAgICAgICBjb25zdCBwdXp6bGVTZXREYXRhQXJyYXkgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHV6emxlU2V0RGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwdXp6bGVTZXQgPSBwdXp6bGVTZXREYXRhQXJyYXlbaV07XG4gICAgICAgICAgICBwdXp6bGVTZXQuX19wcm90b19fID0gUHV6emxlU2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIHB1enpsZVNldHMucHVzaChwdXp6bGVTZXQpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0T3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICBzZWxlY3RPcHRpb24udmFsdWUgPSBpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBzZWxlY3RPcHRpb24uaW5uZXJUZXh0ID0gcHV6emxlU2V0LnRpdGxlO1xuICAgICAgICAgICAgcHV6emxlU2VsZWN0b3IuYXBwZW5kQ2hpbGQoc2VsZWN0T3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChwdXp6bGVTZXRzLm1hcCh2ID0+IHYud2FpdEZvckltYWdlTG9hZCgpKSk7XG4gICAgICAgIHJldHVybiBwdXp6bGVTZXRzO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0U2l6ZUhhbmRsZXIoKSB7XG4gICAgZ2FtZS5zZXRTaXplKHNpemVJbnB1dC52YWx1ZUFzTnVtYmVyLCAuLi5kZWNvZGVCbGFuaygpKTtcbn1cbmxvYWRQdXp6bGVTZXRzKCkudGhlbigocHV6emxlU2V0cykgPT4ge1xuICAgIHN0YXJ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2KSA9PiB7XG4gICAgICAgIGdhbWUuc2h1ZmZsZSgpO1xuICAgICAgICBnYW1lLmluaXRQaWVjZVBvc2l0aW9uKCk7XG4gICAgICAgIGdhbWUuc3RhcnQoZXYudGltZVN0YW1wKTtcbiAgICB9KTtcbiAgICBibGFua1Bvc2l0aW9uU2VsZWN0b3IudG9wTGVmdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHNldFNpemVIYW5kbGVyKTtcbiAgICBibGFua1Bvc2l0aW9uU2VsZWN0b3IudG9wUmlnaHQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBzZXRTaXplSGFuZGxlcik7XG4gICAgYmxhbmtQb3NpdGlvblNlbGVjdG9yLmJvdHRvbUxlZnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBzZXRTaXplSGFuZGxlcik7XG4gICAgYmxhbmtQb3NpdGlvblNlbGVjdG9yLmJvdHRvbVJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0Jywgc2V0U2l6ZUhhbmRsZXIpO1xuICAgIHNpemVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBzZXRTaXplSGFuZGxlcik7XG4gICAgcHV6emxlU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXYgPT4ge1xuICAgICAgICBnYW1lLnNldFB1enpsZVNldChwdXp6bGVTZXRzW3B1enpsZVNlbGVjdG9yLnZhbHVlXSk7XG4gICAgfSk7XG4gICAgbGFiZWxTZWxlY3Rvci5ub25lLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZXYgPT4ge1xuICAgICAgICBnYW1lLnNob3dMYWJlbCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIGxhYmVsU2VsZWN0b3IucGhvbmUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBldiA9PiB7XG4gICAgICAgIGdhbWUuc2hvd0xhYmVsID0gdHJ1ZTtcbiAgICAgICAgZ2FtZS5hc3NpZ25MYWJlbChmYWxzZSk7XG4gICAgfSk7XG4gICAgbGFiZWxTZWxlY3Rvci5rZXlwYWQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBldiA9PiB7XG4gICAgICAgIGdhbWUuc2hvd0xhYmVsID0gdHJ1ZTtcbiAgICAgICAgZ2FtZS5hc3NpZ25MYWJlbCh0cnVlKTtcbiAgICB9KTtcbiAgICBsZXQgcHV6emxlU2V0ID0gcHV6emxlU2V0c1twdXp6bGVTZWxlY3Rvci52YWx1ZV07XG4gICAgbGV0IHNpemUgPSBzaXplSW5wdXQudmFsdWVBc051bWJlcjtcbiAgICBnYW1lID0gbmV3IEdhbWUoc2l6ZSwgcHV6emxlU2V0LCAyMCwgMjAsIDMyMCwgbGFiZWxTZWxlY3Rvci5rZXlwYWQuY2hlY2tlZCk7XG4gICAgaW5wdXQgPSBuZXcgTW91c2VJbnB1dCgpO1xuICAgIGlucHV0LmNvbm5lY3QoY2FudmFzLCBnYW1lKTtcbiAgICBjbG9jayA9IG5ldyBSQUZQdWxzZUNsb2NrKHQgPT4ge1xuICAgICAgICBpbnB1dC51cGRhdGUoKTtcbiAgICAgICAgZ2FtZS51cGRhdGUodCwgaW5wdXQpO1xuICAgICAgICBnYW1lLnJlbmRlcihjb250ZXh0KTtcbiAgICB9KTtcbiAgICBjbG9jay5ydW4oKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! exports provided: getRowCol, getPosition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRowCol\", function() { return getRowCol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPosition\", function() { return getPosition; });\nfunction quantize(pos, parentSize, offset, divideBy) {\n    let n = Math.floor((pos - offset) / (parentSize / divideBy));\n    return n;\n}\n/**\n * 왼쪽 경계가 left, 오른쪽 경계가 top인 정사각형 parentSize를 정사각행렬 꼴로 divideBy만큼 나누었을 때, 좌표 (x, y)가 속한 행렬 위치\n */\nfunction getRowCol(x, y, parentSize, left, top, divideBy) {\n    return [\n        quantize(y, parentSize, top, divideBy),\n        quantize(x, parentSize, left, divideBy)\n    ];\n}\n/**\n * 왼쪽 경계가 left, 오른쪽 경계가 top인 정사각형 parentSize를 정사각행렬 꼴로 divideBy만큼 나누었을 때, row행 col열에 있는 부분 정사각형의 왼쪽 위 좌표\n */\nfunction getPosition(row, col, parentSize, left, top, divideBy) {\n    let d = parentSize / divideBy;\n    return [left + col * d, top + row * d];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMudHM/MjA1MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL3V0aWxzLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcXVhbnRpemUocG9zLCBwYXJlbnRTaXplLCBvZmZzZXQsIGRpdmlkZUJ5KSB7XG4gICAgbGV0IG4gPSBNYXRoLmZsb29yKChwb3MgLSBvZmZzZXQpIC8gKHBhcmVudFNpemUgLyBkaXZpZGVCeSkpO1xuICAgIHJldHVybiBuO1xufVxuLyoqXG4gKiDsmbzsqr0g6rK96rOE6rCAIGxlZnQsIOyYpOuluOyqvSDqsr3qs4TqsIAgdG9w7J24IOygleyCrOqwge2YlSBwYXJlbnRTaXpl66W8IOygleyCrOqwge2WieugrCDqvLTroZwgZGl2aWRlQnnrp4ztgbwg64KY64iE7JeI7J2EIOuVjCwg7KKM7ZGcICh4LCB5KeqwgCDsho3tlZwg7ZaJ66CsIOychOy5mFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um93Q29sKHgsIHksIHBhcmVudFNpemUsIGxlZnQsIHRvcCwgZGl2aWRlQnkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBxdWFudGl6ZSh5LCBwYXJlbnRTaXplLCB0b3AsIGRpdmlkZUJ5KSxcbiAgICAgICAgcXVhbnRpemUoeCwgcGFyZW50U2l6ZSwgbGVmdCwgZGl2aWRlQnkpXG4gICAgXTtcbn1cbi8qKlxuICog7Jm87Kq9IOqyveqzhOqwgCBsZWZ0LCDsmKTrpbjsqr0g6rK96rOE6rCAIHRvcOyduCDsoJXsgqzqsIHtmJUgcGFyZW50U2l6ZeulvCDsoJXsgqzqsIHtlonroKwg6ry066GcIGRpdmlkZUJ566eM7YG8IOuCmOuIhOyXiOydhCDrlYwsIHJvd+2WiSBjb2zsl7Tsl5Ag7J6I64qUIOu2gOu2hCDsoJXsgqzqsIHtmJXsnZgg7Jm87Kq9IOychCDsooztkZxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKHJvdywgY29sLCBwYXJlbnRTaXplLCBsZWZ0LCB0b3AsIGRpdmlkZUJ5KSB7XG4gICAgbGV0IGQgPSBwYXJlbnRTaXplIC8gZGl2aWRlQnk7XG4gICAgcmV0dXJuIFtsZWZ0ICsgY29sICogZCwgdG9wICsgcm93ICogZF07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils.ts\n");

/***/ })

/******/ });