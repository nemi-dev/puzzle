/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _Piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Piece */ \"./src/Piece.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony import */ var _Grab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Grab */ \"./src/Grab.ts\");\n/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Timer */ \"./src/Timer.ts\");\n\r\n\r\n\r\n\r\n/** 퍼즐에서 아무 퍼즐 조각이나 선택하여, 그 조각의 행렬 위치를 얻는다. */\r\nfunction selectRealPiece(model, blankTag) {\r\n    while (true) {\r\n        let i = Math.floor(Math.random() * model.length);\r\n        if (model[i] != blankTag)\r\n            return i;\r\n    }\r\n}\r\n/** 퍼즐의 해결 가능 여부를 실제로 판단한다. */\r\nfunction checkSolvable(model, blankTag) {\r\n    let blankIndex = model.indexOf(blankTag);\r\n    let size = Math.sqrt(model.length);\r\n    let blankRow = Math.floor(blankIndex / size);\r\n    let inversion = 0;\r\n    for (let i = 0; i < model.length; i++) {\r\n        if (model[i] == blankTag)\r\n            continue;\r\n        for (let j = i + 1; j < model.length; j++) {\r\n            if (model[j] == blankTag)\r\n                continue;\r\n            if (model[i] > model[j])\r\n                inversion++;\r\n        }\r\n    }\r\n    // return inversion % 2 == parity;\r\n    return (inversion + ((size % 2 == 0) ? blankRow + 1 : 0)) % 2 == 0;\r\n}\r\nclass Game {\r\n    constructor(size, puzzleSet, left, top, len, timerHeight) {\r\n        /**\r\n         * 게임 진행 중 여부\r\n         *\r\n         * false : 아직 시작 버튼을 누르지 않은 상태.\r\n         *  - 플레이어는 퍼즐 조각을 요리조리 움직여볼 수 있다.\r\n         *  - 타이머가 진행되지 않는다.\r\n         *  - 우연찮게 퍼즐을 완성시켜도 인정하지 않는다.\r\n         *\r\n         * true : 플레이 중\r\n         *  - 타이머가 진행된다.\r\n         *  - 퍼즐을 완성시키면 클리어한 것으로 인정되고, 완성 이펙트가 뜨고, 이 값이 false로 돌아간다.\r\n         */\r\n        this.playing = false;\r\n        /** 이 게임에서 빈 칸에 해당하는 태그 */\r\n        this.blankTag = 0;\r\n        /** 이 게임에서 번호를 표시할지 여부 */\r\n        this.showLabel = false;\r\n        this._bottomBlank = true;\r\n        this._rightBlank = false;\r\n        this._upsideDown = false;\r\n        /** 퍼즐 조각의 움직임을 컨트롤하는 컴포넌트 */\r\n        this.grab = new _Grab__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\r\n        this.handlePlay = this._noop;\r\n        /**\r\n         * 퍼즐을 완성했을 때 실행시킬 외부 콜백 목록\r\n         * 왜 콜백을 외부에서 받는지는 모르겠지만, 아무튼 쓰고싶은 함수가 외부에 있다고!!\r\n         * */\r\n        this.completeHandlers = [];\r\n        this.left = left;\r\n        this.top = top;\r\n        this.len = len;\r\n        this.timer = new _Timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\r\n        this.timer.y = top * 2 + len + timerHeight / 2;\r\n        this.timer.fontSize = timerHeight * 5 / 12;\r\n        this.timer.left = left;\r\n        this.timer.width = len;\r\n        this.viewWidth = left * 2 + len;\r\n        this.viewHeight = top * 2 + len + timerHeight;\r\n        this._size = size;\r\n        this.setPuzzleSet(puzzleSet);\r\n    }\r\n    /** 캔버스에서 퍼즐의 오른쪽 끝 위치 */\r\n    get right() { return this.left + this.len; }\r\n    /** 캔버스에서 퍼즐의 아래쪽 끝 위치 */\r\n    get bottom() { return this.top + this.len; }\r\n    /** 한 행 또는 열의 퍼즐 조각의 수 */\r\n    get size() { return this._size; }\r\n    /** 퍼즐 조각 하나의 변의 길이 */\r\n    get pieceSize() { return this.len / this._size; }\r\n    /** 현재 빈 칸의 행렬 위치 */\r\n    get rowColOfBlank() {\r\n        let i = this.puzzleModel.indexOf(this.blankTag);\r\n        return [Math.floor(i / this._size), i % this._size];\r\n    }\r\n    /**\r\n     * 생성된 퍼즐 조각에 번호를 처음으로 또는 다시 붙인다.\r\n     * 번호를 붙이는 것은 게임 초기화를 요구하지 않는다.\r\n     * */\r\n    assignLabel(upsideDown) {\r\n        this._upsideDown = upsideDown;\r\n        const totalPieces = this._size * this._size;\r\n        for (let tag = 0; tag < totalPieces; tag++) {\r\n            let vrow = Math.floor(tag / this._size);\r\n            let vcol = tag % this._size;\r\n            let lrow = upsideDown ? this._size - vrow - 1 : vrow;\r\n            let label = lrow * this._size + vcol + 1;\r\n            this.pieces[tag].label = label.toString();\r\n        }\r\n    }\r\n    /** 퍼즐 크기를 설정한다. 게임 재설정이 요구된다. */\r\n    setSize(size, bottomBlank, rightBlank) {\r\n        this.end(null);\r\n        this.timer.reset();\r\n        this._size = size;\r\n        this._bottomBlank = bottomBlank;\r\n        this._rightBlank = rightBlank;\r\n        const t = size * size;\r\n        this.puzzleModel = new Array(t);\r\n        this.pieces = new Array(t);\r\n        const pieceLength = this._puzzleSet.size / size;\r\n        for (let tag = 0; tag < t; tag++) {\r\n            this.puzzleModel[tag] = tag;\r\n            let row = Math.floor(tag / size);\r\n            let col = tag % size;\r\n            let [x, y] = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getPosition\"])(row, col, this._puzzleSet.size, this._puzzleSet.left, this._puzzleSet.top, size);\r\n            this.pieces[tag] = new _Piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"](tag, this._puzzleSet.texture, x, y, pieceLength, this.len / size);\r\n        }\r\n        this.blankTag = (this._size * (this._size - 1)) * Number(bottomBlank) + (this._size - 1) * Number(rightBlank);\r\n        this.assignLabel(this._upsideDown);\r\n        this.initPiecePosition();\r\n    }\r\n    /** 퍼즐셋을 변경한다. 참조 범위가 바뀔 수 있으므로 setSize가 후속적으로 실행된다. */\r\n    setPuzzleSet(puzzleSet) {\r\n        this._puzzleSet = puzzleSet;\r\n        this.solvable = puzzleSet.solvable;\r\n        this.setSize(this._size, this._bottomBlank, this._rightBlank);\r\n    }\r\n    /** 퍼즐을 섞는다. Game 내에 있는 solvable 속성이 적용된다. */\r\n    shuffle() {\r\n        this.puzzleModel.sort(() => 0.5 - Math.random());\r\n        if (checkSolvable(this.puzzleModel, this.blankTag) != this.solvable) {\r\n            let a = selectRealPiece(this.puzzleModel, this.blankTag);\r\n            let b;\r\n            do {\r\n                b = selectRealPiece(this.puzzleModel, this.blankTag);\r\n            } while (a == b);\r\n            let t = this.puzzleModel[a];\r\n            this.puzzleModel[a] = this.puzzleModel[b];\r\n            this.puzzleModel[b] = t;\r\n        }\r\n    }\r\n    /**\r\n     * 퍼즐 조각들을 모두 제자리에 놓는다.\r\n     * (퍼즐 조각의 위치를 퍼즐 모델과 일치시킨다.)\r\n     * */\r\n    initPiecePosition() {\r\n        const totalPieces = this._size * this._size;\r\n        const num = this._size;\r\n        const len = this.len;\r\n        for (let i = 0; i < totalPieces; i++) {\r\n            const tag = this.puzzleModel[i];\r\n            let row = Math.floor(i / num);\r\n            let col = (i % num);\r\n            let piece = this.pieces[tag];\r\n            piece.destX = this.left + col * len / num;\r\n            piece.destY = this.top + row * len / num;\r\n            piece.getIntoPositionNow();\r\n        }\r\n    }\r\n    /** (x, y) 좌표의 행렬 위치를 얻는다. */\r\n    getRowColAt(x, y) {\r\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"getRowCol\"])(x, y, this.len, this.left, this.top, this._size);\r\n    }\r\n    /** 지정 행렬 위치에 있는 퍼즐 조각을 얻는다. */\r\n    getPieceAt(row, col) {\r\n        let foundPosition = col + row * this._size;\r\n        let foundTag = this.puzzleModel[foundPosition];\r\n        return this.pieces[foundTag];\r\n    }\r\n    /** index번째 행벡터/열벡터를 얻는다. */\r\n    getVector(index, orient) {\r\n        let ar = new Array(this._size);\r\n        let start, increment;\r\n        switch (orient) {\r\n            case \"row\":\r\n                start = index * this._size;\r\n                increment = 1;\r\n                break;\r\n            case \"col\":\r\n                start = index;\r\n                increment = this._size;\r\n                break;\r\n        }\r\n        for (let i = 0; i < this._size; i++) {\r\n            ar[i] = this.pieces[this.puzzleModel[start + increment * i]];\r\n        }\r\n        return ar;\r\n    }\r\n    /** rAF에 동기화된 마우스 클릭 핸들러 */\r\n    dispatchMousedown(m) {\r\n        this.grab.onMousedown(m, this);\r\n        // 아직 제 자리를 못 찾고 헤매는 조각이 있으면 곧바로 destX,destY 값을 적용시켜 즉시 이동한다.\r\n        for (const piece of this.pieces) {\r\n            if (piece.tag != this.blankTag)\r\n                piece.getIntoPositionNow();\r\n        }\r\n    }\r\n    /** rAF에 동기화된 마우스 놓기 핸들러 */\r\n    dispatchMouseup(m) {\r\n        this.grab.onMouseup(m, this);\r\n    }\r\n    _noop() { }\r\n    _updateForPlaying(t) {\r\n        if (this.isSolved()) {\r\n            this.onComplete(t);\r\n            return;\r\n        }\r\n        this.timer.update(t);\r\n    }\r\n    /** 게임을 시작한다. */\r\n    start(startTime) {\r\n        this.handlePlay = this._updateForPlaying;\r\n        this.playing = true;\r\n        this.timer.start(startTime);\r\n    }\r\n    /** 게임을 끝낸다. (게임 중단, 게임 클리어 모두 포함) */\r\n    end(endTime) {\r\n        this.handlePlay = this._noop;\r\n        this.playing = false;\r\n        this.timer.end(endTime);\r\n    }\r\n    /** 퍼즐이 완성되었는지 판단한다. */\r\n    isSolved() {\r\n        for (let i = 0; i < this.puzzleModel.length; i++) {\r\n            if (this.puzzleModel[i] != i)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    /** 퍼즐을 완성했을 때 실행된다. */\r\n    onComplete(t) {\r\n        this.end(t);\r\n        for (const cb of this.completeHandlers) {\r\n            cb();\r\n        }\r\n    }\r\n    /**\r\n     * 주어진 좌표를 클릭했을 때 마우스 드래그/놓기 이벤트를 활성화시킬 것인지 여부\r\n     * accept되지 않으면 **입력 자체가 완전히 무시되어 버린다.**\r\n     */\r\n    acceptCoordinate(x, y) {\r\n        // 퍼즐 밖 영역을 클릭하면 드래그로 이어지지 않는다.\r\n        if (x < this.left || x > this.right || y < this.top || y > this.bottom)\r\n            return false;\r\n        // 움직일 수 없는 조각을 클릭하면 드래그로 이어지지 않는다.\r\n        let [blankRow, blankCol] = this.rowColOfBlank;\r\n        let [row, col] = this.getRowColAt(x, y);\r\n        if ((blankRow == row) == (blankCol == col))\r\n            return false;\r\n        return true;\r\n    }\r\n    /**\r\n     * 매 rAF마다 호출된다.\r\n     *\r\n     * 이게 실행되기 전에 다음 것들이 이 순서대로 실행되었다.\r\n     * - input.dispatch()\r\n     * \t- dispatchMousedown, dispatchMouseup이 메시지 큐의 순서에 따라 모두 처리되었다.\r\n     * - input에 \"현재 상태\" 저장됨\r\n     *\r\n     * 이게 실행되고 나면 다음 것들이 차례로 실행될 것이다.\r\n     * - input.pulse()\r\n     *  - 현재 값이 이전 값으로(.beforeX, .beforeY) 전이된다.\r\n     * */\r\n    update(t, input) {\r\n        this.handlePlay(t);\r\n        if (this.grab.piece) {\r\n            this.grab.update(this, input);\r\n        }\r\n        for (const piece of this.pieces) {\r\n            if (piece.tag != this.blankTag)\r\n                piece.update(this);\r\n        }\r\n    }\r\n    /** 그린다. */\r\n    render(context) {\r\n        context.clearRect(0, 0, this.viewWidth, this.viewHeight);\r\n        for (const piece of this.pieces) {\r\n            if (piece.tag != this.blankTag)\r\n                piece.render(context, this.showLabel);\r\n        }\r\n        this.timer.render(context);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR2FtZS50cz83NDllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0QjtBQUNxQjtBQUN2QjtBQUNFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBVztBQUNwQyxtQ0FBbUMsOENBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvR2FtZS50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQaWVjZSBmcm9tIFwiLi9QaWVjZVwiO1xyXG5pbXBvcnQgeyBnZXRSb3dDb2wsIGdldFBvc2l0aW9uIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuaW1wb3J0IEdyYWIgZnJvbSBcIi4vR3JhYlwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vVGltZXJcIjtcclxuLyoqIO2NvOymkOyXkOyEnCDslYTrrLQg7Y287KaQIOyhsOqwgeydtOuCmCDshKDtg53tlZjsl6wsIOq3uCDsobDqsIHsnZgg7ZaJ66CsIOychOy5mOulvCDslrvripTri6QuICovXHJcbmZ1bmN0aW9uIHNlbGVjdFJlYWxQaWVjZShtb2RlbCwgYmxhbmtUYWcpIHtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgbGV0IGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtb2RlbC5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChtb2RlbFtpXSAhPSBibGFua1RhZylcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbn1cclxuLyoqIO2NvOymkOydmCDtlbTqsrAg6rCA64qlIOyXrOu2gOulvCDsi6TsoJzroZwg7YyQ64uo7ZWc64ukLiAqL1xyXG5mdW5jdGlvbiBjaGVja1NvbHZhYmxlKG1vZGVsLCBibGFua1RhZykge1xyXG4gICAgbGV0IGJsYW5rSW5kZXggPSBtb2RlbC5pbmRleE9mKGJsYW5rVGFnKTtcclxuICAgIGxldCBzaXplID0gTWF0aC5zcXJ0KG1vZGVsLmxlbmd0aCk7XHJcbiAgICBsZXQgYmxhbmtSb3cgPSBNYXRoLmZsb29yKGJsYW5rSW5kZXggLyBzaXplKTtcclxuICAgIGxldCBpbnZlcnNpb24gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChtb2RlbFtpXSA9PSBibGFua1RhZylcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbW9kZWwubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKG1vZGVsW2pdID09IGJsYW5rVGFnKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChtb2RlbFtpXSA+IG1vZGVsW2pdKVxyXG4gICAgICAgICAgICAgICAgaW52ZXJzaW9uKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcmV0dXJuIGludmVyc2lvbiAlIDIgPT0gcGFyaXR5O1xyXG4gICAgcmV0dXJuIChpbnZlcnNpb24gKyAoKHNpemUgJSAyID09IDApID8gYmxhbmtSb3cgKyAxIDogMCkpICUgMiA9PSAwO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWUge1xyXG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgcHV6emxlU2V0LCBsZWZ0LCB0b3AsIGxlbiwgdGltZXJIZWlnaHQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDqsozsnoQg7KeE7ZaJIOykkSDsl6zrtoBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGZhbHNlIDog7JWE7KeBIOyLnOyekSDrsoTtirzsnYQg64iE66W07KeAIOyViuydgCDsg4Htg5wuXHJcbiAgICAgICAgICogIC0g7ZSM66CI7J207Ja064qUIO2NvOymkCDsobDqsIHsnYQg7JqU66as7KGw66asIOybgOyngeyXrOuzvCDsiJgg7J6I64ukLlxyXG4gICAgICAgICAqICAtIO2DgOydtOuouOqwgCDsp4TtlonrkJjsp4Ag7JWK64qU64ukLlxyXG4gICAgICAgICAqICAtIOyasOyXsOywruqyjCDtjbzsppDsnYQg7JmE7ISx7Iuc7Lyc64+EIOyduOygle2VmOyngCDslYrripTri6QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiB0cnVlIDog7ZSM66CI7J20IOykkVxyXG4gICAgICAgICAqICAtIO2DgOydtOuouOqwgCDsp4TtlonrkJzri6QuXHJcbiAgICAgICAgICogIC0g7Y287KaQ7J2EIOyZhOyEseyLnO2CpOuptCDtgbTrpqzslrTtlZwg6rKD7Jy866GcIOyduOygleuQmOqzoCwg7JmE7ISxIOydtO2Ome2KuOqwgCDrnKjqs6AsIOydtCDqsJLsnbQgZmFsc2XroZwg64+M7JWE6rCE64ukLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKiDsnbQg6rKM7J6E7JeQ7IScIOu5iCDsubjsl5Ag7ZW064u57ZWY64qUIO2DnOq3uCAqL1xyXG4gICAgICAgIHRoaXMuYmxhbmtUYWcgPSAwO1xyXG4gICAgICAgIC8qKiDsnbQg6rKM7J6E7JeQ7IScIOuyiO2YuOulvCDtkZzsi5ztlaDsp4Ag7Jes67aAICovXHJcbiAgICAgICAgdGhpcy5zaG93TGFiZWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ib3R0b21CbGFuayA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmlnaHRCbGFuayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Vwc2lkZURvd24gPSBmYWxzZTtcclxuICAgICAgICAvKiog7Y287KaQIOyhsOqwgeydmCDsm4Dsp4HsnoTsnYQg7Luo7Yq466Gk7ZWY64qUIOy7tO2PrOuEjO2KuCAqL1xyXG4gICAgICAgIHRoaXMuZ3JhYiA9IG5ldyBHcmFiKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQbGF5ID0gdGhpcy5fbm9vcDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDtjbzsppDsnYQg7JmE7ISx7ZaI7J2EIOuVjCDsi6Ttlonsi5ztgqwg7Jm467aAIOy9nOuwsSDrqqnroZ1cclxuICAgICAgICAgKiDsmZwg7L2c67Cx7J2EIOyZuOu2gOyXkOyEnCDrsJvripTsp4DripQg66qo66W06rKg7KeA66eMLCDslYTrrLTtirwg7JOw6rOg7Iu27J2AIO2VqOyImOqwgCDsmbjrtoDsl5Ag7J6I64uk6rOgISFcclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVIYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XHJcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XHJcbiAgICAgICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcigpO1xyXG4gICAgICAgIHRoaXMudGltZXIueSA9IHRvcCAqIDIgKyBsZW4gKyB0aW1lckhlaWdodCAvIDI7XHJcbiAgICAgICAgdGhpcy50aW1lci5mb250U2l6ZSA9IHRpbWVySGVpZ2h0ICogNSAvIDEyO1xyXG4gICAgICAgIHRoaXMudGltZXIubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy50aW1lci53aWR0aCA9IGxlbjtcclxuICAgICAgICB0aGlzLnZpZXdXaWR0aCA9IGxlZnQgKiAyICsgbGVuO1xyXG4gICAgICAgIHRoaXMudmlld0hlaWdodCA9IHRvcCAqIDIgKyBsZW4gKyB0aW1lckhlaWdodDtcclxuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcclxuICAgICAgICB0aGlzLnNldFB1enpsZVNldChwdXp6bGVTZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqIOy6lOuyhOyKpOyXkOyEnCDtjbzsppDsnZgg7Jik66W47Kq9IOuBnSDsnITsuZggKi9cclxuICAgIGdldCByaWdodCgpIHsgcmV0dXJuIHRoaXMubGVmdCArIHRoaXMubGVuOyB9XHJcbiAgICAvKiog7LqU67KE7Iqk7JeQ7IScIO2NvOymkOydmCDslYTrnpjsqr0g64GdIOychOy5mCAqL1xyXG4gICAgZ2V0IGJvdHRvbSgpIHsgcmV0dXJuIHRoaXMudG9wICsgdGhpcy5sZW47IH1cclxuICAgIC8qKiDtlZwg7ZaJIOuYkOuKlCDsl7TsnZgg7Y287KaQIOyhsOqwgeydmCDsiJggKi9cclxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5fc2l6ZTsgfVxyXG4gICAgLyoqIO2NvOymkCDsobDqsIEg7ZWY64KY7J2YIOuzgOydmCDquLjsnbQgKi9cclxuICAgIGdldCBwaWVjZVNpemUoKSB7IHJldHVybiB0aGlzLmxlbiAvIHRoaXMuX3NpemU7IH1cclxuICAgIC8qKiDtmITsnqwg67mIIOy5uOydmCDtlonroKwg7JyE7LmYICovXHJcbiAgICBnZXQgcm93Q29sT2ZCbGFuaygpIHtcclxuICAgICAgICBsZXQgaSA9IHRoaXMucHV6emxlTW9kZWwuaW5kZXhPZih0aGlzLmJsYW5rVGFnKTtcclxuICAgICAgICByZXR1cm4gW01hdGguZmxvb3IoaSAvIHRoaXMuX3NpemUpLCBpICUgdGhpcy5fc2l6ZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOyDneyEseuQnCDtjbzsppAg7KGw6rCB7JeQIOuyiO2YuOulvCDsspjsnYzsnLzroZwg65iQ64qUIOuLpOyLnCDrtpnsnbjri6QuXHJcbiAgICAgKiDrsojtmLjrpbwg67aZ7J2064qUIOqyg+ydgCDqsozsnoQg7LSI6riw7ZmU66W8IOyalOq1rO2VmOyngCDslYrripTri6QuXHJcbiAgICAgKiAqL1xyXG4gICAgYXNzaWduTGFiZWwodXBzaWRlRG93bikge1xyXG4gICAgICAgIHRoaXMuX3Vwc2lkZURvd24gPSB1cHNpZGVEb3duO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsUGllY2VzID0gdGhpcy5fc2l6ZSAqIHRoaXMuX3NpemU7XHJcbiAgICAgICAgZm9yIChsZXQgdGFnID0gMDsgdGFnIDwgdG90YWxQaWVjZXM7IHRhZysrKSB7XHJcbiAgICAgICAgICAgIGxldCB2cm93ID0gTWF0aC5mbG9vcih0YWcgLyB0aGlzLl9zaXplKTtcclxuICAgICAgICAgICAgbGV0IHZjb2wgPSB0YWcgJSB0aGlzLl9zaXplO1xyXG4gICAgICAgICAgICBsZXQgbHJvdyA9IHVwc2lkZURvd24gPyB0aGlzLl9zaXplIC0gdnJvdyAtIDEgOiB2cm93O1xyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBscm93ICogdGhpcy5fc2l6ZSArIHZjb2wgKyAxO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlc1t0YWddLmxhYmVsID0gbGFiZWwudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiog7Y287KaQIO2BrOq4sOulvCDshKTsoJXtlZzri6QuIOqyjOyehCDsnqzshKTsoJXsnbQg7JqU6rWs65Cc64ukLiAqL1xyXG4gICAgc2V0U2l6ZShzaXplLCBib3R0b21CbGFuaywgcmlnaHRCbGFuaykge1xyXG4gICAgICAgIHRoaXMuZW5kKG51bGwpO1xyXG4gICAgICAgIHRoaXMudGltZXIucmVzZXQoKTtcclxuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcclxuICAgICAgICB0aGlzLl9ib3R0b21CbGFuayA9IGJvdHRvbUJsYW5rO1xyXG4gICAgICAgIHRoaXMuX3JpZ2h0QmxhbmsgPSByaWdodEJsYW5rO1xyXG4gICAgICAgIGNvbnN0IHQgPSBzaXplICogc2l6ZTtcclxuICAgICAgICB0aGlzLnB1enpsZU1vZGVsID0gbmV3IEFycmF5KHQpO1xyXG4gICAgICAgIHRoaXMucGllY2VzID0gbmV3IEFycmF5KHQpO1xyXG4gICAgICAgIGNvbnN0IHBpZWNlTGVuZ3RoID0gdGhpcy5fcHV6emxlU2V0LnNpemUgLyBzaXplO1xyXG4gICAgICAgIGZvciAobGV0IHRhZyA9IDA7IHRhZyA8IHQ7IHRhZysrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHV6emxlTW9kZWxbdGFnXSA9IHRhZztcclxuICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IodGFnIC8gc2l6ZSk7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSB0YWcgJSBzaXplO1xyXG4gICAgICAgICAgICBsZXQgW3gsIHldID0gZ2V0UG9zaXRpb24ocm93LCBjb2wsIHRoaXMuX3B1enpsZVNldC5zaXplLCB0aGlzLl9wdXp6bGVTZXQubGVmdCwgdGhpcy5fcHV6emxlU2V0LnRvcCwgc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGllY2VzW3RhZ10gPSBuZXcgUGllY2UodGFnLCB0aGlzLl9wdXp6bGVTZXQudGV4dHVyZSwgeCwgeSwgcGllY2VMZW5ndGgsIHRoaXMubGVuIC8gc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmxhbmtUYWcgPSAodGhpcy5fc2l6ZSAqICh0aGlzLl9zaXplIC0gMSkpICogTnVtYmVyKGJvdHRvbUJsYW5rKSArICh0aGlzLl9zaXplIC0gMSkgKiBOdW1iZXIocmlnaHRCbGFuayk7XHJcbiAgICAgICAgdGhpcy5hc3NpZ25MYWJlbCh0aGlzLl91cHNpZGVEb3duKTtcclxuICAgICAgICB0aGlzLmluaXRQaWVjZVBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKiog7Y287KaQ7IWL7J2EIOuzgOqyve2VnOuLpC4g7LC47KGwIOuylOychOqwgCDrsJTrgJQg7IiYIOyeiOycvOuvgOuhnCBzZXRTaXpl6rCAIO2bhOyGjeyggeycvOuhnCDsi6TtlonrkJzri6QuICovXHJcbiAgICBzZXRQdXp6bGVTZXQocHV6emxlU2V0KSB7XHJcbiAgICAgICAgdGhpcy5fcHV6emxlU2V0ID0gcHV6emxlU2V0O1xyXG4gICAgICAgIHRoaXMuc29sdmFibGUgPSBwdXp6bGVTZXQuc29sdmFibGU7XHJcbiAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuX3NpemUsIHRoaXMuX2JvdHRvbUJsYW5rLCB0aGlzLl9yaWdodEJsYW5rKTtcclxuICAgIH1cclxuICAgIC8qKiDtjbzsppDsnYQg7ISe64qU64ukLiBHYW1lIOuCtOyXkCDsnojripQgc29sdmFibGUg7IaN7ISx7J20IOyggeyaqeuQnOuLpC4gKi9cclxuICAgIHNodWZmbGUoKSB7XHJcbiAgICAgICAgdGhpcy5wdXp6bGVNb2RlbC5zb3J0KCgpID0+IDAuNSAtIE1hdGgucmFuZG9tKCkpO1xyXG4gICAgICAgIGlmIChjaGVja1NvbHZhYmxlKHRoaXMucHV6emxlTW9kZWwsIHRoaXMuYmxhbmtUYWcpICE9IHRoaXMuc29sdmFibGUpIHtcclxuICAgICAgICAgICAgbGV0IGEgPSBzZWxlY3RSZWFsUGllY2UodGhpcy5wdXp6bGVNb2RlbCwgdGhpcy5ibGFua1RhZyk7XHJcbiAgICAgICAgICAgIGxldCBiO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBiID0gc2VsZWN0UmVhbFBpZWNlKHRoaXMucHV6emxlTW9kZWwsIHRoaXMuYmxhbmtUYWcpO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChhID09IGIpO1xyXG4gICAgICAgICAgICBsZXQgdCA9IHRoaXMucHV6emxlTW9kZWxbYV07XHJcbiAgICAgICAgICAgIHRoaXMucHV6emxlTW9kZWxbYV0gPSB0aGlzLnB1enpsZU1vZGVsW2JdO1xyXG4gICAgICAgICAgICB0aGlzLnB1enpsZU1vZGVsW2JdID0gdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIO2NvOymkCDsobDqsIHrk6TsnYQg66qo65GQIOygnOyekOumrOyXkCDrhpPripTri6QuXHJcbiAgICAgKiAo7Y287KaQIOyhsOqwgeydmCDsnITsuZjrpbwg7Y287KaQIOuqqOuNuOqzvCDsnbzsuZjsi5ztgqjri6QuKVxyXG4gICAgICogKi9cclxuICAgIGluaXRQaWVjZVBvc2l0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHRvdGFsUGllY2VzID0gdGhpcy5fc2l6ZSAqIHRoaXMuX3NpemU7XHJcbiAgICAgICAgY29uc3QgbnVtID0gdGhpcy5fc2l6ZTtcclxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsUGllY2VzOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnID0gdGhpcy5wdXp6bGVNb2RlbFtpXTtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaSAvIG51bSk7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSAoaSAlIG51bSk7XHJcbiAgICAgICAgICAgIGxldCBwaWVjZSA9IHRoaXMucGllY2VzW3RhZ107XHJcbiAgICAgICAgICAgIHBpZWNlLmRlc3RYID0gdGhpcy5sZWZ0ICsgY29sICogbGVuIC8gbnVtO1xyXG4gICAgICAgICAgICBwaWVjZS5kZXN0WSA9IHRoaXMudG9wICsgcm93ICogbGVuIC8gbnVtO1xyXG4gICAgICAgICAgICBwaWVjZS5nZXRJbnRvUG9zaXRpb25Ob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogKHgsIHkpIOyijO2RnOydmCDtlonroKwg7JyE7LmY66W8IOyWu+uKlOuLpC4gKi9cclxuICAgIGdldFJvd0NvbEF0KHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Um93Q29sKHgsIHksIHRoaXMubGVuLCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLl9zaXplKTtcclxuICAgIH1cclxuICAgIC8qKiDsp4DsoJUg7ZaJ66CsIOychOy5mOyXkCDsnojripQg7Y287KaQIOyhsOqwgeydhCDslrvripTri6QuICovXHJcbiAgICBnZXRQaWVjZUF0KHJvdywgY29sKSB7XHJcbiAgICAgICAgbGV0IGZvdW5kUG9zaXRpb24gPSBjb2wgKyByb3cgKiB0aGlzLl9zaXplO1xyXG4gICAgICAgIGxldCBmb3VuZFRhZyA9IHRoaXMucHV6emxlTW9kZWxbZm91bmRQb3NpdGlvbl07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGllY2VzW2ZvdW5kVGFnXTtcclxuICAgIH1cclxuICAgIC8qKiBpbmRleOuyiOynuCDtlonrsqHthLAv7Je067Kh7YSw66W8IOyWu+uKlOuLpC4gKi9cclxuICAgIGdldFZlY3RvcihpbmRleCwgb3JpZW50KSB7XHJcbiAgICAgICAgbGV0IGFyID0gbmV3IEFycmF5KHRoaXMuX3NpemUpO1xyXG4gICAgICAgIGxldCBzdGFydCwgaW5jcmVtZW50O1xyXG4gICAgICAgIHN3aXRjaCAob3JpZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyb3dcIjpcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXggKiB0aGlzLl9zaXplO1xyXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiY29sXCI6XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gdGhpcy5fc2l6ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xyXG4gICAgICAgICAgICBhcltpXSA9IHRoaXMucGllY2VzW3RoaXMucHV6emxlTW9kZWxbc3RhcnQgKyBpbmNyZW1lbnQgKiBpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH1cclxuICAgIC8qKiByQUbsl5Ag64+Z6riw7ZmU65CcIOuniOyasOyKpCDtgbTrpq0g7ZW465Ok65+sICovXHJcbiAgICBkaXNwYXRjaE1vdXNlZG93bihtKSB7XHJcbiAgICAgICAgdGhpcy5ncmFiLm9uTW91c2Vkb3duKG0sIHRoaXMpO1xyXG4gICAgICAgIC8vIOyVhOyngSDsoJwg7J6Q66as66W8IOuquyDssL7qs6Ag7Zek66ek64qUIOyhsOqwgeydtCDsnojsnLzrqbQg6rOn67CU66GcIGRlc3RYLGRlc3RZIOqwkuydhCDsoIHsmqnsi5zsvJwg7KaJ7IucIOydtOuPme2VnOuLpC5cclxuICAgICAgICBmb3IgKGNvbnN0IHBpZWNlIG9mIHRoaXMucGllY2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChwaWVjZS50YWcgIT0gdGhpcy5ibGFua1RhZylcclxuICAgICAgICAgICAgICAgIHBpZWNlLmdldEludG9Qb3NpdGlvbk5vdygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiByQUbsl5Ag64+Z6riw7ZmU65CcIOuniOyasOyKpCDrhpPquLAg7ZW465Ok65+sICovXHJcbiAgICBkaXNwYXRjaE1vdXNldXAobSkge1xyXG4gICAgICAgIHRoaXMuZ3JhYi5vbk1vdXNldXAobSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBfbm9vcCgpIHsgfVxyXG4gICAgX3VwZGF0ZUZvclBsYXlpbmcodCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU29sdmVkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKHQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZXIudXBkYXRlKHQpO1xyXG4gICAgfVxyXG4gICAgLyoqIOqyjOyehOydhCDsi5zsnpHtlZzri6QuICovXHJcbiAgICBzdGFydChzdGFydFRpbWUpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVBsYXkgPSB0aGlzLl91cGRhdGVGb3JQbGF5aW5nO1xyXG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50aW1lci5zdGFydChzdGFydFRpbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqIOqyjOyehOydhCDrgZ3rgrjri6QuICjqsozsnoQg7KSR64uoLCDqsozsnoQg7YG066as7Ja0IOuqqOuRkCDtj6ztlagpICovXHJcbiAgICBlbmQoZW5kVGltZSkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGxheSA9IHRoaXMuX25vb3A7XHJcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50aW1lci5lbmQoZW5kVGltZSk7XHJcbiAgICB9XHJcbiAgICAvKiog7Y287KaQ7J20IOyZhOyEseuQmOyXiOuKlOyngCDtjJDri6jtlZzri6QuICovXHJcbiAgICBpc1NvbHZlZCgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucHV6emxlTW9kZWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHV6emxlTW9kZWxbaV0gIT0gaSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKiog7Y287KaQ7J2EIOyZhOyEse2WiOydhCDrlYwg7Iuk7ZaJ65Cc64ukLiAqL1xyXG4gICAgb25Db21wbGV0ZSh0KSB7XHJcbiAgICAgICAgdGhpcy5lbmQodCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLmNvbXBsZXRlSGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOyjvOyWtOynhCDsooztkZzrpbwg7YG066at7ZaI7J2EIOuVjCDrp4jsmrDsiqQg65Oc656Y6re4L+uGk+q4sCDsnbTrsqTtirjrpbwg7Zmc7ISx7ZmU7Iuc7YKsIOqyg+yduOyngCDsl6zrtoBcclxuICAgICAqIGFjY2VwdOuQmOyngCDslYrsnLzrqbQgKirsnoXroKUg7J6Q7LK06rCAIOyZhOyghO2eiCDrrLTsi5zrkJjslrQg67KE66aw64ukLioqXHJcbiAgICAgKi9cclxuICAgIGFjY2VwdENvb3JkaW5hdGUoeCwgeSkge1xyXG4gICAgICAgIC8vIO2NvOymkCDrsJYg7JiB7Jet7J2EIO2BtOumre2VmOuptCDrk5zrnpjqt7jroZwg7J207Ja07KeA7KeAIOyViuuKlOuLpC5cclxuICAgICAgICBpZiAoeCA8IHRoaXMubGVmdCB8fCB4ID4gdGhpcy5yaWdodCB8fCB5IDwgdGhpcy50b3AgfHwgeSA+IHRoaXMuYm90dG9tKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8g7JuA7KeB7J28IOyImCDsl4bripQg7KGw6rCB7J2EIO2BtOumre2VmOuptCDrk5zrnpjqt7jroZwg7J207Ja07KeA7KeAIOyViuuKlOuLpC5cclxuICAgICAgICBsZXQgW2JsYW5rUm93LCBibGFua0NvbF0gPSB0aGlzLnJvd0NvbE9mQmxhbms7XHJcbiAgICAgICAgbGV0IFtyb3csIGNvbF0gPSB0aGlzLmdldFJvd0NvbEF0KHgsIHkpO1xyXG4gICAgICAgIGlmICgoYmxhbmtSb3cgPT0gcm93KSA9PSAoYmxhbmtDb2wgPT0gY29sKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDrp6QgckFG66eI64ukIO2YuOy2nOuQnOuLpC5cclxuICAgICAqXHJcbiAgICAgKiDsnbTqsowg7Iuk7ZaJ65CY6riwIOyghOyXkCDri6TsnYwg6rKD65Ok7J20IOydtCDsiJzshJzrjIDroZwg7Iuk7ZaJ65CY7JeI64ukLlxyXG4gICAgICogLSBpbnB1dC5kaXNwYXRjaCgpXHJcbiAgICAgKiBcdC0gZGlzcGF0Y2hNb3VzZWRvd24sIGRpc3BhdGNoTW91c2V1cOydtCDrqZTsi5zsp4Ag7YGQ7J2YIOyInOyEnOyXkCDrlLDrnbwg66qo65GQIOyymOumrOuQmOyXiOuLpC5cclxuICAgICAqIC0gaW5wdXTsl5AgXCLtmITsnqwg7IOB7YOcXCIg7KCA7J6l65CoXHJcbiAgICAgKlxyXG4gICAgICog7J206rKMIOyLpO2WieuQmOqzoCDrgpjrqbQg64uk7J2MIOqyg+uTpOydtCDssKjroYDroZwg7Iuk7ZaJ65CgIOqyg+ydtOuLpC5cclxuICAgICAqIC0gaW5wdXQucHVsc2UoKVxyXG4gICAgICogIC0g7ZiE7J6sIOqwkuydtCDsnbTsoIQg6rCS7Jy866GcKC5iZWZvcmVYLCAuYmVmb3JlWSkg7KCE7J2065Cc64ukLlxyXG4gICAgICogKi9cclxuICAgIHVwZGF0ZSh0LCBpbnB1dCkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGxheSh0KTtcclxuICAgICAgICBpZiAodGhpcy5ncmFiLnBpZWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhYi51cGRhdGUodGhpcywgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHBpZWNlIG9mIHRoaXMucGllY2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChwaWVjZS50YWcgIT0gdGhpcy5ibGFua1RhZylcclxuICAgICAgICAgICAgICAgIHBpZWNlLnVwZGF0ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiog6re466aw64ukLiAqL1xyXG4gICAgcmVuZGVyKGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnZpZXdXaWR0aCwgdGhpcy52aWV3SGVpZ2h0KTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBpZWNlIG9mIHRoaXMucGllY2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChwaWVjZS50YWcgIT0gdGhpcy5ibGFua1RhZylcclxuICAgICAgICAgICAgICAgIHBpZWNlLnJlbmRlcihjb250ZXh0LCB0aGlzLnNob3dMYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZXIucmVuZGVyKGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Game.ts\n");

/***/ }),

/***/ "./src/Grab.ts":
/*!*********************!*\
  !*** ./src/Grab.ts ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Grab; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony import */ var _Physical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Physical */ \"./src/Physical.ts\");\n\r\n\r\nconst maximumTapDistance = 31;\r\n/** 현재 누른 퍼즐 조각과 그 주변 조각에 대한 정보를 가지고 있다. */\r\nclass Grab {\r\n    constructor() {\r\n        /** 현재 누른 퍼즐 조각 */\r\n        this.piece = null;\r\n        /** 현재 누른 퍼즐 조각의 원래 행렬 위치 */\r\n        this.row = null;\r\n        this.col = null;\r\n        /** 마우스 버튼이 눌리는 그 순간에 현재 퍼즐 조각의 왼쪽 끝에 상대적인 마우스 위치 */\r\n        this.pieceOffsetX = null;\r\n        this.pieceOffsetY = null;\r\n        /**\r\n         * 현재 누른 퍼즐 조각과 같은 행 또는 열에 있는 조각들의 모음이다.\r\n         * 충돌 테스트는 여기 있는 조각들에 한해서 실행된다.\r\n         */\r\n        this.concern = null;\r\n        /**\r\n         * 현재 누른 퍼즐 조각을 어느 방향으로 움직일 수 있는지 나타낸다.\r\n         * 이 값이 'h'이면 퍼즐 조각을 좌우좌로 움직일 수 있고, 퍼즐 중에서 행(row)이 선택된 것이다.\r\n         * 'v'이면 퍼즐 조각을 세로로 움직일 수 있고, 열(col)이 선택된 것이다.\r\n         */\r\n        this.moveAxis = null;\r\n    }\r\n    /** (rAF-sync) 마우스를 누를 때 실행된다. */\r\n    onMousedown(m, game) {\r\n        // 여기서는 [blankRow, blankCol] != [row, col]이다. 만약 둘이 같다면 이것은 실행조차 되지 않는다.\r\n        let { startX: x, startY: y } = m;\r\n        let [blankRow, blankCol] = game.rowColOfBlank;\r\n        let [row, col] = game.getRowColAt(x, y);\r\n        if (blankRow == row) {\r\n            this.moveAxis = \"h\";\r\n            this.concern = game.getVector(blankRow, \"row\");\r\n        }\r\n        else if (blankCol == col) {\r\n            this.moveAxis = \"v\";\r\n            this.concern = game.getVector(blankCol, \"col\");\r\n        }\r\n        this.row = row;\r\n        this.col = col;\r\n        this.piece = game.getPieceAt(row, col);\r\n        this.pieceOffsetX = x - this.piece.x;\r\n        this.pieceOffsetY = y - this.piece.y;\r\n    }\r\n    /** (rAF-sync) 마우스를 놓을 때 실행된다. */\r\n    onMouseup(m, game) {\r\n        let { startX, startY, endX, endY, startTime, endTime } = m;\r\n        let distance = this.moveAxis == 'h' ? endX - startX : endY - startY;\r\n        /**\r\n         * # 탭인지 아닌지 판단하는 기준\r\n         *\r\n         * 다음 모두를 만족할 것:\r\n         * - 누르기 시간이 특정 수치를 넘지 않음 (기본 권장 시간 : 0.3초)\r\n         * - 변위가 특정 길이를 넘기지 않음\r\n         *\r\n         * ### 변위이어도 되나?\r\n         *\r\n         * 변위가 아닌 \"누적 거리\"로 판단하고자 한다면..\r\n         * 일단 일반적으로는 탭으로 판정되지 않을 만큼의 거리를 짧은 시간 안에 움직이는 것이 어렵다. 제한 거리의 값이 합리적이라면 말이지.\r\n         * 실제로 그렇게 하는 놈이 나온다면 그것은 기계적으로 마우스를 임의 조작한 것이라 판단한다.\r\n         * 그런 놈들을 상대하기 위해 누적 거리를 재느니 더 간단하게 계산할 수 있는 변위를 가지고 판단하겠다.\r\n         */\r\n        let isTap = (endTime - startTime < 300) && (Math.abs(distance) < maximumTapDistance);\r\n        if (isTap) {\r\n            // 퍼즐 조각을 클릭하기만 한 것이라면 모델에서 조각들을 직접 회전시키고, 뷰를 업데이트한다.\r\n            this.updateModelThenView(game);\r\n        }\r\n        else {\r\n            // 퍼즐 조각을 물리적으로 움직인 것이라면 영향을 받은 모든 조각들을 바른 위치에 놓은 후, 모델을 업데이트한다.\r\n            this.updateModelByView(game);\r\n        }\r\n        // 이제 마우스 놓기 처리가 완전히 끝났을 것이므로 데이터를 정리한다.\r\n        this.piece = null;\r\n        this.moveAxis = null;\r\n        this.concern = null;\r\n    }\r\n    /**\r\n     * 모델을 먼저 바꾸고, 뷰가 모델을 따라도록 한다.\r\n     * 이 놈은 마우스를 놓을 때에만 실행되며 마우스 놓기 핸들러와 동등한 것으로 본다.\r\n     */\r\n    updateModelThenView(game) {\r\n        /** 태그의 배열 */\r\n        const vector = [];\r\n        const start = this.moveAxis == 'h' ? this.row * game.size : this.col;\r\n        const increment = this.moveAxis == 'h' ? 1 : game.size;\r\n        // 퍼즐 모델에서 태그의 행벡터 또는 열벡터를 가져온다.\r\n        for (let i = 0; i < game.size; i++) {\r\n            let index = start + increment * i;\r\n            vector[i] = game.puzzleModel[index];\r\n        }\r\n        // 클릭한 퍼즐의 태그가 뭐였더라?\r\n        const currentTag = this.piece.tag;\r\n        const currentTagPos = vector.indexOf(currentTag);\r\n        // 빈칸의 위치를 얻는다.\r\n        const blankTagPos = vector.indexOf(game.blankTag);\r\n        // 빈칸이 현재 퍼즐 조각보다 뒤에(오른쪽 또는 아래) 있는지, 앞에 있는지(왼쪽 또는 위)를 판단한여 회전을 시킨다.\r\n        if (currentTagPos < blankTagPos) {\r\n            vector.splice(blankTagPos, 1);\r\n            vector.splice(currentTagPos, 0, game.blankTag);\r\n        }\r\n        else {\r\n            vector.splice(blankTagPos, 1);\r\n            vector.splice(currentTagPos, 0, game.blankTag);\r\n        }\r\n        // 변경된 모델을 기반으로 조각들의 위치를 업데이트한다.\r\n        for (let i = 0; i < game.size; i++) {\r\n            let index = start + increment * i;\r\n            game.puzzleModel[index] = vector[i];\r\n            let p = game.pieces[vector[i]];\r\n            let [row, col] = [Math.floor(index / game.size), index % game.size];\r\n            let [destX, destY] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getPosition\"])(row, col, game.len, game.left, game.top, game.size);\r\n            p.destX = destX;\r\n            p.destY = destY;\r\n        }\r\n    }\r\n    /**\r\n     * 영향을 받은 퍼즐 조각들의 현재 위치(Piece.prototype.x, Piece.prototype.y)만을 가지고\r\n     * 모델을 업데이트한다. 이 놈은 마우스를 놓을 때에만 실행되며 마우스 놓기 핸들러와 동등한 것으로 본다.\r\n     * @deprecated 속도는 전혀 고려되지 않는다.\r\n     */\r\n    updateModelByView(game) {\r\n        let modelChanges = {};\r\n        for (const piece of this.concern) {\r\n            if (piece.tag == game.blankTag)\r\n                continue;\r\n            // 영향을 받은 모든 퍼즐 조각들의 모델 행렬 위치를 얻는다. \r\n            let [row, col] = piece.whereami(game.left, game.top, game.len, game.size);\r\n            // 변경점에 퍼즐 조각의 새로운 위치를 설정한다.\r\n            modelChanges[row * game.size + col] = piece.tag;\r\n            // 조각이 새로운 위치로 이동하도록 destX, destY를 설정한다.\r\n            let destX = game.left + col * game.pieceSize;\r\n            let destY = game.top + row * game.pieceSize;\r\n            piece.destX = destX;\r\n            piece.destY = destY;\r\n        }\r\n        // 옮기기 이후 모델의 변경점(changes)을 찾는다.\r\n        const start = this.moveAxis == 'h' ? this.row * game.size : this.col;\r\n        const increment = this.moveAxis == 'h' ? 1 : game.size;\r\n        // 빈칸을 찾는다.\r\n        for (let i = 0; i < game.size; i++) {\r\n            let index = start + increment * i;\r\n            if (!(index in modelChanges)) {\r\n                modelChanges[index] = game.blankTag;\r\n                break;\r\n            }\r\n        }\r\n        // 변경점을 퍼즐 모델에 적용시킨다.\r\n        for (const index in modelChanges) {\r\n            const tag = modelChanges[index];\r\n            game.puzzleModel[index] = tag;\r\n        }\r\n    }\r\n    /** 마우스를 누르고 있는 때에 한해 업데이트(rAF)가 발생할 때 호출된다. 즉, 실질적 업데이트와 같다. */\r\n    update(game, holdInput) {\r\n        if (this.moveAxis == \"h\" && holdInput.beforeX != null) {\r\n            let x = holdInput.x - this.pieceOffsetX;\r\n            this.piece.velX = x - this.piece.x;\r\n        }\r\n        else if (this.moveAxis == \"v\" && holdInput.beforeY != null) {\r\n            let y = holdInput.y - this.pieceOffsetY;\r\n            this.piece.velY = y - this.piece.y;\r\n        }\r\n        this.resolveCollision(game);\r\n    }\r\n    /**\r\n     * 현재 concern과 **grabbing에 대하여** 충돌 해결을 한 번 한다.\r\n     * 이것은 오로지\r\n     * # 잡고 있는 퍼즐만이 실제 속도를 가질 수 있다\r\n     * 는 것을 가정으로 실행된다.\r\n     *\r\n     * 이것은 단 한 번의 호출로 충돌을 해결할 수 있다.\r\n     *\r\n     * 위치관계를 이해하기 위해 현재상태를 보존할 필요성마저 없을 정도.\r\n     */\r\n    resolveCollision(game) {\r\n        const blankTag = game.blankTag;\r\n        const maxCount = this.concern.length;\r\n        // 이 충돌 테스트는 잡고 있는 조각을 중심으로 하여 이전 방향과 이후 방향으로 전파(propagation)된다.\r\n        const gIndex = this.moveAxis == \"h\" ? this.col : this.row;\r\n        const [pos, vel] = this.moveAxis == \"h\" ? [\"x\", \"velX\"] : [\"y\", \"velY\"];\r\n        // 현재 축 상에서 잡은 조각의 속도를 알아낸다.\r\n        const gVel = this.piece[vel];\r\n        const gVsign = Math.sign(gVel);\r\n        if (gVsign != 0) {\r\n            // 누른 조각이 움직이는 방향 위에 있는 조각들만 생각하면 된다.\t\t\r\n            for (let a = gIndex; (a >= 0) && (a < maxCount); a += gVsign) {\r\n                const A = this.concern[a];\r\n                if (A.tag == blankTag)\r\n                    continue;\r\n                for (let b = a + gVsign; (b >= 0) && (b < maxCount); b += gVsign) {\r\n                    const B = this.concern[b];\r\n                    if (B.tag == blankTag)\r\n                        continue;\r\n                    if (Object(_Physical__WEBPACK_IMPORTED_MODULE_1__[\"willHit\"])(A, B, this.moveAxis)) {\r\n                        B[pos] = A[pos] + A[vel] + B.size * gVsign;\r\n                    }\r\n                }\r\n            }\r\n            // 벽을 알아낸다.\r\n            // 잡고 있는 조각 외에는 움직이지 않으므로 잡고 있는 조각이 어디(위, 아래, 왼쪽, 오른쪽)를 향하는지에 대해서만 영향을 받는다.\r\n            // 끝점(right, bottom)에 대해서 size를 빼는 이유는, 비교를 용이하게 하기 위함이다.\r\n            let backpressureLimit;\r\n            if (this.moveAxis == \"h\") {\r\n                backpressureLimit = gVsign < 0 ? game.left : game.right - this.piece.size;\r\n            }\r\n            else {\r\n                backpressureLimit = gVsign < 0 ? game.top : game.bottom - this.piece.size;\r\n            }\r\n            // 벽에 가장 가까운 조각의 인덱스(빈칸 포함)를 알아낸다.\r\n            const [start, end] = gVsign < 0 ? [0, maxCount] : [maxCount - 1, -1];\r\n            for (let i = start; i != end; i -= gVsign) {\r\n                if (this.concern[i].tag == game.blankTag)\r\n                    continue;\r\n                const piece = this.concern[i];\r\n                /*\r\n                다음의 식은 각각의 경우에 따라 이렇게 해석된다.\r\n                - 왼쪽 진행인 경우 : concern[i][pos] = .x; gVsign = -1; backpressureLimit = left (+ N);\r\n                    => -.x + left > 0\r\n                    => .x < left\r\n                - 오른쪽 진행인 경우 : concern[i][pos] = .x; gVsign = 1; backpressureLimit = right - size (+ N);\r\n                    => x - right + size > 0\r\n                    => x > right - size\r\n                - 위로 진행인 경우 : concern[i][pos] = .y; gVsign = -1; backpressureLimit = top (+ N);\r\n                    => -.y + top > 0\r\n                    => .y < top\r\n                - 아래로 진행인 경우 : concern[i][pos] = .y; gVsign = 1; backpressureLimit = bottom - size (+ N);\r\n                    => .y - bottom + size > 0\r\n                    => .y > bottom - size\r\n                */\r\n                // 백프레스를 받을지 여부를 나타낸다. 백프레스를 받은 조각은 예외없이 조각의 움직임이 멈춘다.\r\n                if ((piece[pos] + piece[vel] - backpressureLimit) * gVsign > 0) {\r\n                    piece[pos] = backpressureLimit;\r\n                    piece[vel] = 0;\r\n                    backpressureLimit += this.piece.size * (-gVsign);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR3JhYi50cz81ZTZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXNDO0FBQ0Q7QUFDckM7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBaUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMERBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL0dyYWIudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRQb3NpdGlvbiB9IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7IHdpbGxIaXQgfSBmcm9tIFwiLi9QaHlzaWNhbFwiO1xyXG5jb25zdCBtYXhpbXVtVGFwRGlzdGFuY2UgPSAzMTtcclxuLyoqIO2YhOyerCDriITrpbgg7Y287KaQIOyhsOqwgeqzvCDqt7gg7KO867OAIOyhsOqwgeyXkCDrjIDtlZwg7KCV67O066W8IOqwgOyngOqzoCDsnojri6QuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYWIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqIO2YhOyerCDriITrpbgg7Y287KaQIOyhsOqwgSAqL1xyXG4gICAgICAgIHRoaXMucGllY2UgPSBudWxsO1xyXG4gICAgICAgIC8qKiDtmITsnqwg64iE66W4IO2NvOymkCDsobDqsIHsnZgg7JuQ656YIO2WieugrCDsnITsuZggKi9cclxuICAgICAgICB0aGlzLnJvdyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb2wgPSBudWxsO1xyXG4gICAgICAgIC8qKiDrp4jsmrDsiqQg67KE7Yq87J20IOuIjOumrOuKlCDqt7gg7Iic6rCE7JeQIO2YhOyerCDtjbzsppAg7KGw6rCB7J2YIOyZvOyqvSDrgZ3sl5Ag7IOB64yA7KCB7J24IOuniOyasOyKpCDsnITsuZggKi9cclxuICAgICAgICB0aGlzLnBpZWNlT2Zmc2V0WCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5waWVjZU9mZnNldFkgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIO2YhOyerCDriITrpbgg7Y287KaQIOyhsOqwgeqzvCDqsJnsnYAg7ZaJIOuYkOuKlCDsl7Tsl5Ag7J6I64qUIOyhsOqwgeuTpOydmCDrqqjsnYzsnbTri6QuXHJcbiAgICAgICAgICog7Lap64+MIO2FjOyKpO2KuOuKlCDsl6zquLAg7J6I64qUIOyhsOqwgeuTpOyXkCDtlZztlbTshJwg7Iuk7ZaJ65Cc64ukLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29uY2VybiA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog7ZiE7J6sIOuIhOuluCDtjbzsppAg7KGw6rCB7J2EIOyWtOuKkCDrsKntlqXsnLzroZwg7JuA7KeB7J28IOyImCDsnojripTsp4Ag64KY7YOA64K464ukLlxyXG4gICAgICAgICAqIOydtCDqsJLsnbQgJ2gn7J2066m0IO2NvOymkCDsobDqsIHsnYQg7KKM7Jqw7KKM66GcIOybgOyngeydvCDsiJgg7J6I6rOgLCDtjbzsppAg7KSR7JeQ7IScIO2WiShyb3cp7J20IOyEoO2DneuQnCDqsoPsnbTri6QuXHJcbiAgICAgICAgICogJ3Yn7J2066m0IO2NvOymkCDsobDqsIHsnYQg7IS466Gc66GcIOybgOyngeydvCDsiJgg7J6I6rOgLCDsl7QoY29sKeydtCDshKDtg53rkJwg6rKD7J2064ukLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubW92ZUF4aXMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIChyQUYtc3luYykg66eI7Jqw7Iqk66W8IOuIhOulvCDrlYwg7Iuk7ZaJ65Cc64ukLiAqL1xyXG4gICAgb25Nb3VzZWRvd24obSwgZ2FtZSkge1xyXG4gICAgICAgIC8vIOyXrOq4sOyEnOuKlCBbYmxhbmtSb3csIGJsYW5rQ29sXSAhPSBbcm93LCBjb2xd7J2064ukLiDrp4zslb0g65GY7J20IOqwmeuLpOuptCDsnbTqsoPsnYAg7Iuk7ZaJ7KGw7LCoIOuQmOyngCDslYrripTri6QuXHJcbiAgICAgICAgbGV0IHsgc3RhcnRYOiB4LCBzdGFydFk6IHkgfSA9IG07XHJcbiAgICAgICAgbGV0IFtibGFua1JvdywgYmxhbmtDb2xdID0gZ2FtZS5yb3dDb2xPZkJsYW5rO1xyXG4gICAgICAgIGxldCBbcm93LCBjb2xdID0gZ2FtZS5nZXRSb3dDb2xBdCh4LCB5KTtcclxuICAgICAgICBpZiAoYmxhbmtSb3cgPT0gcm93KSB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZUF4aXMgPSBcImhcIjtcclxuICAgICAgICAgICAgdGhpcy5jb25jZXJuID0gZ2FtZS5nZXRWZWN0b3IoYmxhbmtSb3csIFwicm93XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChibGFua0NvbCA9PSBjb2wpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlQXhpcyA9IFwidlwiO1xyXG4gICAgICAgICAgICB0aGlzLmNvbmNlcm4gPSBnYW1lLmdldFZlY3RvcihibGFua0NvbCwgXCJjb2xcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm93ID0gcm93O1xyXG4gICAgICAgIHRoaXMuY29sID0gY29sO1xyXG4gICAgICAgIHRoaXMucGllY2UgPSBnYW1lLmdldFBpZWNlQXQocm93LCBjb2wpO1xyXG4gICAgICAgIHRoaXMucGllY2VPZmZzZXRYID0geCAtIHRoaXMucGllY2UueDtcclxuICAgICAgICB0aGlzLnBpZWNlT2Zmc2V0WSA9IHkgLSB0aGlzLnBpZWNlLnk7XHJcbiAgICB9XHJcbiAgICAvKiogKHJBRi1zeW5jKSDrp4jsmrDsiqTrpbwg64aT7J2EIOuVjCDsi6TtlonrkJzri6QuICovXHJcbiAgICBvbk1vdXNldXAobSwgZ2FtZSkge1xyXG4gICAgICAgIGxldCB7IHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBzdGFydFRpbWUsIGVuZFRpbWUgfSA9IG07XHJcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gdGhpcy5tb3ZlQXhpcyA9PSAnaCcgPyBlbmRYIC0gc3RhcnRYIDogZW5kWSAtIHN0YXJ0WTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAjIO2DreyduOyngCDslYTri4zsp4Ag7YyQ64uo7ZWY64qUIOq4sOykgFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICog64uk7J2MIOuqqOuRkOulvCDrp4zsobHtlaAg6rKDOlxyXG4gICAgICAgICAqIC0g64iE66W06riwIOyLnOqwhOydtCDtirnsoJUg7IiY7LmY66W8IOuEmOyngCDslYrsnYwgKOq4sOuzuCDqtozsnqUg7Iuc6rCEIDogMC4z7LSIKVxyXG4gICAgICAgICAqIC0g67OA7JyE6rCAIO2KueyglSDquLjsnbTrpbwg64SY6riw7KeAIOyViuydjFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIyMjIOuzgOychOydtOyWtOuPhCDrkJjrgpg/XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiDrs4DsnITqsIAg7JWE64uMIFwi64iE7KCBIOqxsOumrFwi66GcIO2MkOuLqO2VmOqzoOyekCDtlZzri6TrqbQuLlxyXG4gICAgICAgICAqIOydvOuLqCDsnbzrsJjsoIHsnLzroZzripQg7YOt7Jy866GcIO2MkOygleuQmOyngCDslYrsnYQg66eM7YG87J2YIOqxsOumrOulvCDsp6fsnYAg7Iuc6rCEIOyViOyXkCDsm4Dsp4HsnbTripQg6rKD7J20IOyWtOugteuLpC4g7KCc7ZWcIOqxsOumrOydmCDqsJLsnbQg7ZWp66as7KCB7J20652866m0IOunkOydtOyngC5cclxuICAgICAgICAgKiDsi6TsoJzroZwg6re466CH6rKMIO2VmOuKlCDrhojsnbQg64KY7Jio64uk66m0IOq3uOqyg+ydgCDquLDqs4TsoIHsnLzroZwg66eI7Jqw7Iqk66W8IOyehOydmCDsobDsnpHtlZwg6rKD7J206528IO2MkOuLqO2VnOuLpC5cclxuICAgICAgICAgKiDqt7jrn7Ag64aI65Ok7J2EIOyDgeuMgO2VmOq4sCDsnITtlbQg64iE7KCBIOqxsOumrOulvCDsnqzripDri4gg642UIOqwhOuLqO2VmOqyjCDqs4TsgrDtlaAg7IiYIOyeiOuKlCDrs4DsnITrpbwg6rCA7KeA6rOgIO2MkOuLqO2VmOqyoOuLpC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgaXNUYXAgPSAoZW5kVGltZSAtIHN0YXJ0VGltZSA8IDMwMCkgJiYgKE1hdGguYWJzKGRpc3RhbmNlKSA8IG1heGltdW1UYXBEaXN0YW5jZSk7XHJcbiAgICAgICAgaWYgKGlzVGFwKSB7XHJcbiAgICAgICAgICAgIC8vIO2NvOymkCDsobDqsIHsnYQg7YG066at7ZWY6riw66eMIO2VnCDqsoPsnbTrnbzrqbQg66qo64247JeQ7IScIOyhsOqwgeuTpOydhCDsp4HsoJEg7ZqM7KCE7Iuc7YKk6rOgLCDrt7Drpbwg7JeF642w7J207Yq47ZWc64ukLlxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsVGhlblZpZXcoZ2FtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDtjbzsppAg7KGw6rCB7J2EIOusvOumrOyggeycvOuhnCDsm4Dsp4Hsnbgg6rKD7J20652866m0IOyYge2WpeydhCDrsJvsnYAg66qo65OgIOyhsOqwgeuTpOydhCDrsJTrpbgg7JyE7LmY7JeQIOuGk+ydgCDtm4QsIOuqqOuNuOydhCDsl4XrjbDsnbTtirjtlZzri6QuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZWxCeVZpZXcoZ2FtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOydtOygnCDrp4jsmrDsiqQg64aT6riwIOyymOumrOqwgCDsmYTsoITtnogg64Gd64Ks7J2EIOqyg+ydtOuvgOuhnCDrjbDsnbTthLDrpbwg7KCV66as7ZWc64ukLlxyXG4gICAgICAgIHRoaXMucGllY2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubW92ZUF4aXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29uY2VybiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOuqqOuNuOydhCDrqLzsoIAg67CU6r646rOgLCDrt7DqsIAg66qo64247J2EIOuUsOudvOuPhOuhnSDtlZzri6QuXHJcbiAgICAgKiDsnbQg64aI7J2AIOuniOyasOyKpOulvCDrhpPsnYQg65WM7JeQ66eMIOyLpO2WieuQmOupsCDrp4jsmrDsiqQg64aT6riwIO2VuOuTpOufrOyZgCDrj5nrk7HtlZwg6rKD7Jy866GcIOuzuOuLpC5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlTW9kZWxUaGVuVmlldyhnYW1lKSB7XHJcbiAgICAgICAgLyoqIO2DnOq3uOydmCDrsLDsl7QgKi9cclxuICAgICAgICBjb25zdCB2ZWN0b3IgPSBbXTtcclxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMubW92ZUF4aXMgPT0gJ2gnID8gdGhpcy5yb3cgKiBnYW1lLnNpemUgOiB0aGlzLmNvbDtcclxuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSB0aGlzLm1vdmVBeGlzID09ICdoJyA/IDEgOiBnYW1lLnNpemU7XHJcbiAgICAgICAgLy8g7Y287KaQIOuqqOuNuOyXkOyEnCDtg5zqt7jsnZgg7ZaJ67Kh7YSwIOuYkOuKlCDsl7TrsqHthLDrpbwg6rCA7KC47Jio64ukLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2FtZS5zaXplOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gc3RhcnQgKyBpbmNyZW1lbnQgKiBpO1xyXG4gICAgICAgICAgICB2ZWN0b3JbaV0gPSBnYW1lLnB1enpsZU1vZGVsW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g7YG066at7ZWcIO2NvOymkOydmCDtg5zqt7jqsIAg662Q7JiA642U6528P1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYWcgPSB0aGlzLnBpZWNlLnRhZztcclxuICAgICAgICBjb25zdCBjdXJyZW50VGFnUG9zID0gdmVjdG9yLmluZGV4T2YoY3VycmVudFRhZyk7XHJcbiAgICAgICAgLy8g67mI7Lm47J2YIOychOy5mOulvCDslrvripTri6QuXHJcbiAgICAgICAgY29uc3QgYmxhbmtUYWdQb3MgPSB2ZWN0b3IuaW5kZXhPZihnYW1lLmJsYW5rVGFnKTtcclxuICAgICAgICAvLyDruYjsubjsnbQg7ZiE7J6sIO2NvOymkCDsobDqsIHrs7Tri6Qg65Kk7JeQKOyYpOuluOyqvSDrmJDripQg7JWE656YKSDsnojripTsp4AsIOyVnuyXkCDsnojripTsp4Ao7Jm87Kq9IOuYkOuKlCDsnIQp66W8IO2MkOuLqO2VnOyXrCDtmozsoITsnYQg7Iuc7YKo64ukLlxyXG4gICAgICAgIGlmIChjdXJyZW50VGFnUG9zIDwgYmxhbmtUYWdQb3MpIHtcclxuICAgICAgICAgICAgdmVjdG9yLnNwbGljZShibGFua1RhZ1BvcywgMSk7XHJcbiAgICAgICAgICAgIHZlY3Rvci5zcGxpY2UoY3VycmVudFRhZ1BvcywgMCwgZ2FtZS5ibGFua1RhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2ZWN0b3Iuc3BsaWNlKGJsYW5rVGFnUG9zLCAxKTtcclxuICAgICAgICAgICAgdmVjdG9yLnNwbGljZShjdXJyZW50VGFnUG9zLCAwLCBnYW1lLmJsYW5rVGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g67OA6rK965CcIOuqqOuNuOydhCDquLDrsJjsnLzroZwg7KGw6rCB65Ok7J2YIOychOy5mOulvCDsl4XrjbDsnbTtirjtlZzri6QuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lLnNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBzdGFydCArIGluY3JlbWVudCAqIGk7XHJcbiAgICAgICAgICAgIGdhbWUucHV6emxlTW9kZWxbaW5kZXhdID0gdmVjdG9yW2ldO1xyXG4gICAgICAgICAgICBsZXQgcCA9IGdhbWUucGllY2VzW3ZlY3RvcltpXV07XHJcbiAgICAgICAgICAgIGxldCBbcm93LCBjb2xdID0gW01hdGguZmxvb3IoaW5kZXggLyBnYW1lLnNpemUpLCBpbmRleCAlIGdhbWUuc2l6ZV07XHJcbiAgICAgICAgICAgIGxldCBbZGVzdFgsIGRlc3RZXSA9IGdldFBvc2l0aW9uKHJvdywgY29sLCBnYW1lLmxlbiwgZ2FtZS5sZWZ0LCBnYW1lLnRvcCwgZ2FtZS5zaXplKTtcclxuICAgICAgICAgICAgcC5kZXN0WCA9IGRlc3RYO1xyXG4gICAgICAgICAgICBwLmRlc3RZID0gZGVzdFk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDsmIHtlqXsnYQg67Cb7J2AIO2NvOymkCDsobDqsIHrk6TsnZgg7ZiE7J6sIOychOy5mChQaWVjZS5wcm90b3R5cGUueCwgUGllY2UucHJvdG90eXBlLnkp66eM7J2EIOqwgOyngOqzoFxyXG4gICAgICog66qo64247J2EIOyXheuNsOydtO2KuO2VnOuLpC4g7J20IOuGiOydgCDrp4jsmrDsiqTrpbwg64aT7J2EIOuVjOyXkOunjCDsi6TtlonrkJjrqbAg66eI7Jqw7IqkIOuGk+q4sCDtlbjrk6Trn6zsmYAg64+Z65Ox7ZWcIOqyg+ycvOuhnCDrs7jri6QuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCDsho3rj4TripQg7KCE7ZiAIOqzoOugpOuQmOyngCDslYrripTri6QuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU1vZGVsQnlWaWV3KGdhbWUpIHtcclxuICAgICAgICBsZXQgbW9kZWxDaGFuZ2VzID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiB0aGlzLmNvbmNlcm4pIHtcclxuICAgICAgICAgICAgaWYgKHBpZWNlLnRhZyA9PSBnYW1lLmJsYW5rVGFnKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIC8vIOyYge2WpeydhCDrsJvsnYAg66qo65OgIO2NvOymkCDsobDqsIHrk6TsnZgg66qo6424IO2WieugrCDsnITsuZjrpbwg7Ja764qU64ukLiBcclxuICAgICAgICAgICAgbGV0IFtyb3csIGNvbF0gPSBwaWVjZS53aGVyZWFtaShnYW1lLmxlZnQsIGdhbWUudG9wLCBnYW1lLmxlbiwgZ2FtZS5zaXplKTtcclxuICAgICAgICAgICAgLy8g67OA6rK97KCQ7JeQIO2NvOymkCDsobDqsIHsnZgg7IOI66Gc7Jq0IOychOy5mOulvCDshKTsoJXtlZzri6QuXHJcbiAgICAgICAgICAgIG1vZGVsQ2hhbmdlc1tyb3cgKiBnYW1lLnNpemUgKyBjb2xdID0gcGllY2UudGFnO1xyXG4gICAgICAgICAgICAvLyDsobDqsIHsnbQg7IOI66Gc7Jq0IOychOy5mOuhnCDsnbTrj5ntlZjrj4TroZ0gZGVzdFgsIGRlc3RZ66W8IOyEpOygle2VnOuLpC5cclxuICAgICAgICAgICAgbGV0IGRlc3RYID0gZ2FtZS5sZWZ0ICsgY29sICogZ2FtZS5waWVjZVNpemU7XHJcbiAgICAgICAgICAgIGxldCBkZXN0WSA9IGdhbWUudG9wICsgcm93ICogZ2FtZS5waWVjZVNpemU7XHJcbiAgICAgICAgICAgIHBpZWNlLmRlc3RYID0gZGVzdFg7XHJcbiAgICAgICAgICAgIHBpZWNlLmRlc3RZID0gZGVzdFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOyYruq4sOq4sCDsnbTtm4Qg66qo64247J2YIOuzgOqyveygkChjaGFuZ2VzKeydhCDssL7ripTri6QuXHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1vdmVBeGlzID09ICdoJyA/IHRoaXMucm93ICogZ2FtZS5zaXplIDogdGhpcy5jb2w7XHJcbiAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gdGhpcy5tb3ZlQXhpcyA9PSAnaCcgPyAxIDogZ2FtZS5zaXplO1xyXG4gICAgICAgIC8vIOu5iOy5uOydhCDssL7ripTri6QuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lLnNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBzdGFydCArIGluY3JlbWVudCAqIGk7XHJcbiAgICAgICAgICAgIGlmICghKGluZGV4IGluIG1vZGVsQ2hhbmdlcykpIHtcclxuICAgICAgICAgICAgICAgIG1vZGVsQ2hhbmdlc1tpbmRleF0gPSBnYW1lLmJsYW5rVGFnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g67OA6rK97KCQ7J2EIO2NvOymkCDrqqjrjbjsl5Ag7KCB7Jqp7Iuc7YKo64ukLlxyXG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gbW9kZWxDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IG1vZGVsQ2hhbmdlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGdhbWUucHV6emxlTW9kZWxbaW5kZXhdID0gdGFnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiDrp4jsmrDsiqTrpbwg64iE66W06rOgIOyeiOuKlCDrlYzsl5Ag7ZWc7ZW0IOyXheuNsOydtO2KuChyQUYp6rCAIOuwnOyDne2VoCDrlYwg7Zi47Lac65Cc64ukLiDspoksIOyLpOyniOyggSDsl4XrjbDsnbTtirjsmYAg6rCZ64ukLiAqL1xyXG4gICAgdXBkYXRlKGdhbWUsIGhvbGRJbnB1dCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1vdmVBeGlzID09IFwiaFwiICYmIGhvbGRJbnB1dC5iZWZvcmVYICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHggPSBob2xkSW5wdXQueCAtIHRoaXMucGllY2VPZmZzZXRYO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlLnZlbFggPSB4IC0gdGhpcy5waWVjZS54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vdmVBeGlzID09IFwidlwiICYmIGhvbGRJbnB1dC5iZWZvcmVZICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHkgPSBob2xkSW5wdXQueSAtIHRoaXMucGllY2VPZmZzZXRZO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlLnZlbFkgPSB5IC0gdGhpcy5waWVjZS55O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc29sdmVDb2xsaXNpb24oZ2FtZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIO2YhOyerCBjb25jZXJu6rO8ICoqZ3JhYmJpbmfsl5Ag64yA7ZWY7JesKiog7Lap64+MIO2VtOqysOydhCDtlZwg67KIIO2VnOuLpC5cclxuICAgICAqIOydtOqyg+ydgCDsmKTroZzsp4BcclxuICAgICAqICMg7J6h6rOgIOyeiOuKlCDtjbzsppDrp4zsnbQg7Iuk7KCcIOyGjeuPhOulvCDqsIDsp4gg7IiYIOyeiOuLpFxyXG4gICAgICog64qUIOqyg+ydhCDqsIDsoJXsnLzroZwg7Iuk7ZaJ65Cc64ukLlxyXG4gICAgICpcclxuICAgICAqIOydtOqyg+ydgCDri6gg7ZWcIOuyiOydmCDtmLjstpzroZwg7Lap64+M7J2EIO2VtOqysO2VoCDsiJgg7J6I64ukLlxyXG4gICAgICpcclxuICAgICAqIOychOy5mOq0gOqzhOulvCDsnbTtlbTtlZjquLAg7JyE7ZW0IO2YhOyerOyDge2DnOulvCDrs7TsobTtlaAg7ZWE7JqU7ISx66eI7KCAIOyXhuydhCDsoJXrj4QuXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVDb2xsaXNpb24oZ2FtZSkge1xyXG4gICAgICAgIGNvbnN0IGJsYW5rVGFnID0gZ2FtZS5ibGFua1RhZztcclxuICAgICAgICBjb25zdCBtYXhDb3VudCA9IHRoaXMuY29uY2Vybi5sZW5ndGg7XHJcbiAgICAgICAgLy8g7J20IOy2qeuPjCDthYzsiqTtirjripQg7J6h6rOgIOyeiOuKlCDsobDqsIHsnYQg7KSR7Ius7Jy866GcIO2VmOyXrCDsnbTsoIQg67Cp7Zal6rO8IOydtO2bhCDrsKntlqXsnLzroZwg7KCE7YyMKHByb3BhZ2F0aW9uKeuQnOuLpC5cclxuICAgICAgICBjb25zdCBnSW5kZXggPSB0aGlzLm1vdmVBeGlzID09IFwiaFwiID8gdGhpcy5jb2wgOiB0aGlzLnJvdztcclxuICAgICAgICBjb25zdCBbcG9zLCB2ZWxdID0gdGhpcy5tb3ZlQXhpcyA9PSBcImhcIiA/IFtcInhcIiwgXCJ2ZWxYXCJdIDogW1wieVwiLCBcInZlbFlcIl07XHJcbiAgICAgICAgLy8g7ZiE7J6sIOy2lSDsg4Hsl5DshJwg7J6h7J2AIOyhsOqwgeydmCDsho3rj4Trpbwg7JWM7JWE64K464ukLlxyXG4gICAgICAgIGNvbnN0IGdWZWwgPSB0aGlzLnBpZWNlW3ZlbF07XHJcbiAgICAgICAgY29uc3QgZ1ZzaWduID0gTWF0aC5zaWduKGdWZWwpO1xyXG4gICAgICAgIGlmIChnVnNpZ24gIT0gMCkge1xyXG4gICAgICAgICAgICAvLyDriITrpbgg7KGw6rCB7J20IOybgOyngeydtOuKlCDrsKntlqUg7JyE7JeQIOyeiOuKlCDsobDqsIHrk6Trp4wg7IOd6rCB7ZWY66m0IOuQnOuLpC5cdFx0XHJcbiAgICAgICAgICAgIGZvciAobGV0IGEgPSBnSW5kZXg7IChhID49IDApICYmIChhIDwgbWF4Q291bnQpOyBhICs9IGdWc2lnbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IHRoaXMuY29uY2VyblthXTtcclxuICAgICAgICAgICAgICAgIGlmIChBLnRhZyA9PSBibGFua1RhZylcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSBhICsgZ1ZzaWduOyAoYiA+PSAwKSAmJiAoYiA8IG1heENvdW50KTsgYiArPSBnVnNpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBCID0gdGhpcy5jb25jZXJuW2JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCLnRhZyA9PSBibGFua1RhZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbGxIaXQoQSwgQiwgdGhpcy5tb3ZlQXhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQltwb3NdID0gQVtwb3NdICsgQVt2ZWxdICsgQi5zaXplICogZ1ZzaWduO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDrsr3snYQg7JWM7JWE64K464ukLlxyXG4gICAgICAgICAgICAvLyDsnqHqs6Ag7J6I64qUIOyhsOqwgSDsmbjsl5DripQg7JuA7KeB7J207KeAIOyViuycvOuvgOuhnCDsnqHqs6Ag7J6I64qUIOyhsOqwgeydtCDslrTrlJQo7JyELCDslYTrnpgsIOyZvOyqvSwg7Jik66W47Kq9KeulvCDtlqXtlZjripTsp4Dsl5Ag64yA7ZW07ISc66eMIOyYge2WpeydhCDrsJvripTri6QuXHJcbiAgICAgICAgICAgIC8vIOuBneygkChyaWdodCwgYm90dG9tKeyXkCDrjIDtlbTshJwgc2l6ZeulvCDrubzripQg7J207Jyg64qULCDruYTqtZDrpbwg7Jqp7J207ZWY6rKMIO2VmOq4sCDsnITtlajsnbTri6QuXHJcbiAgICAgICAgICAgIGxldCBiYWNrcHJlc3N1cmVMaW1pdDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubW92ZUF4aXMgPT0gXCJoXCIpIHtcclxuICAgICAgICAgICAgICAgIGJhY2twcmVzc3VyZUxpbWl0ID0gZ1ZzaWduIDwgMCA/IGdhbWUubGVmdCA6IGdhbWUucmlnaHQgLSB0aGlzLnBpZWNlLnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiYWNrcHJlc3N1cmVMaW1pdCA9IGdWc2lnbiA8IDAgPyBnYW1lLnRvcCA6IGdhbWUuYm90dG9tIC0gdGhpcy5waWVjZS5zaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOuyveyXkCDqsIDsnqUg6rCA6rmM7Jq0IOyhsOqwgeydmCDsnbjrjbHsiqQo67mI7Lm4IO2PrO2VqCnrpbwg7JWM7JWE64K464ukLlxyXG4gICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBnVnNpZ24gPCAwID8gWzAsIG1heENvdW50XSA6IFttYXhDb3VudCAtIDEsIC0xXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpICE9IGVuZDsgaSAtPSBnVnNpZ24pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmNlcm5baV0udGFnID09IGdhbWUuYmxhbmtUYWcpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuY29uY2VybltpXTtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICDri6TsnYzsnZgg7Iud7J2AIOqwgeqwgeydmCDqsr3smrDsl5Ag65Sw6528IOydtOugh+qyjCDtlbTshJ3rkJzri6QuXHJcbiAgICAgICAgICAgICAgICAtIOyZvOyqvSDsp4Ttlonsnbgg6rK97JqwIDogY29uY2VybltpXVtwb3NdID0gLng7IGdWc2lnbiA9IC0xOyBiYWNrcHJlc3N1cmVMaW1pdCA9IGxlZnQgKCsgTik7XHJcbiAgICAgICAgICAgICAgICAgICAgPT4gLS54ICsgbGVmdCA+IDBcclxuICAgICAgICAgICAgICAgICAgICA9PiAueCA8IGxlZnRcclxuICAgICAgICAgICAgICAgIC0g7Jik66W47Kq9IOynhO2WieyduCDqsr3smrAgOiBjb25jZXJuW2ldW3Bvc10gPSAueDsgZ1ZzaWduID0gMTsgYmFja3ByZXNzdXJlTGltaXQgPSByaWdodCAtIHNpemUgKCsgTik7XHJcbiAgICAgICAgICAgICAgICAgICAgPT4geCAtIHJpZ2h0ICsgc2l6ZSA+IDBcclxuICAgICAgICAgICAgICAgICAgICA9PiB4ID4gcmlnaHQgLSBzaXplXHJcbiAgICAgICAgICAgICAgICAtIOychOuhnCDsp4Ttlonsnbgg6rK97JqwIDogY29uY2VybltpXVtwb3NdID0gLnk7IGdWc2lnbiA9IC0xOyBiYWNrcHJlc3N1cmVMaW1pdCA9IHRvcCAoKyBOKTtcclxuICAgICAgICAgICAgICAgICAgICA9PiAtLnkgKyB0b3AgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgPT4gLnkgPCB0b3BcclxuICAgICAgICAgICAgICAgIC0g7JWE656Y66GcIOynhO2WieyduCDqsr3smrAgOiBjb25jZXJuW2ldW3Bvc10gPSAueTsgZ1ZzaWduID0gMTsgYmFja3ByZXNzdXJlTGltaXQgPSBib3R0b20gLSBzaXplICgrIE4pO1xyXG4gICAgICAgICAgICAgICAgICAgID0+IC55IC0gYm90dG9tICsgc2l6ZSA+IDBcclxuICAgICAgICAgICAgICAgICAgICA9PiAueSA+IGJvdHRvbSAtIHNpemVcclxuICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvLyDrsLHtlITroIjsiqTrpbwg67Cb7J2E7KeAIOyXrOu2gOulvCDrgpjtg4Drgrjri6QuIOuwse2UhOugiOyKpOulvCDrsJvsnYAg7KGw6rCB7J2AIOyYiOyZuOyXhuydtCDsobDqsIHsnZgg7JuA7KeB7J6E7J20IOupiOy2mOuLpC5cclxuICAgICAgICAgICAgICAgIGlmICgocGllY2VbcG9zXSArIHBpZWNlW3ZlbF0gLSBiYWNrcHJlc3N1cmVMaW1pdCkgKiBnVnNpZ24gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGllY2VbcG9zXSA9IGJhY2twcmVzc3VyZUxpbWl0O1xyXG4gICAgICAgICAgICAgICAgICAgIHBpZWNlW3ZlbF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2twcmVzc3VyZUxpbWl0ICs9IHRoaXMucGllY2Uuc2l6ZSAqICgtZ1ZzaWduKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Grab.ts\n");

/***/ }),

/***/ "./src/Input.ts":
/*!**********************!*\
  !*** ./src/Input.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MouseInput; });\n/**\r\n * 마우스 입력을 받아들여서 리스너에게 전달하는 클래스\r\n * 이 클래스는 requestAnimationFrame()을 사용한 업데이트 패턴에 특화된 구조를 가지고 있다.\r\n * 중요하고 양이 비교적 적은 이벤트(마우스 누름, 마우스 놓음)는 매 이벤트 루프마다 놓치지 않고 캡쳐해 두고, 압도적으로 많이 발생하고 중요하지 않은 이벤트(마우스 움직임)는 변화에 따라 \"현재 상태\"와 \"직전 상태\"만을 저장해 두고 rAF에서 그 상태를 참조하도록 하고 있다.\r\n */\r\nclass MouseInput {\r\n    constructor() {\r\n        /** 중요 이벤트(마우스 누름, 마우스 놓음)를 저장한 큐 */\r\n        this.messages = [];\r\n        /** 어떤 컨트롤(특히 뷰 기반 컨트롤)에 \"배율이 설정\"되었고, 리스너에게 모델 좌표계 기반으로 메시지를 보내고 싶을 때 모든 이벤트에 이 값이 곱해진다. */\r\n        this.scale = 1;\r\n        /**\r\n         * DOM 이벤트가 발생했을 때 임시적으로 캡쳐한 마우스 위치\r\n         * 이것은 이동, 누름, 놓음 모든 종류의 이벤트를 받아들인다\r\n         * Listener가 마우스 좌표를 받아들이면 퍼즐 조각에 바로 반영하지 않고, requestAnimationFrame이 돌아올 때까지 기다린다. (이벤트 핸들링이 rAF보다 훨씬 많이 발생한다.)\r\n         * 따라서 쏟아지는 이벤트로 인해 불필요하게 성능이 저하되는 것을 방지한다.\r\n         * 어떤 이벤트 루프에서 rAF가 발생하지 않으면 해당 루프로 받아들인 좌표는 버려지게 된다.\r\n         * */\r\n        this.inputX = null;\r\n        this.inputY = null;\r\n        /**\r\n         * inputX, inputY는 드래그를 하는 한에서는 현재 위치로 사용될 수 있으나,\r\n         * 드래그를 하지 않는 동안에는 마지막으로 마우스 이벤트가 일어난 지점이 계속 저장되어 있다.\r\n         * 게다가 update()에서 dispatch와 pulse는 마우스 눌림 여부와 관계없이 항상 실행된다.\r\n         * 따라서 inputX, inputY는 \"현재\"를 나타내기에는 부적절하다.\r\n        */\r\n        this.currentX = null;\r\n        this.currentY = null;\r\n        /** (private) 마지막 update(rAF)가 발생하기 직전의 마우스 위치 */\r\n        this._beforeX = null;\r\n        this._beforeY = null;\r\n        /**\r\n         * 마우스 누름 발생 시, 언젠가 발생할 마우스 떼기에 대응하여 임시로 메시지를 만들어 저장해 둘 배열\r\n         * messagePool[n]은 n번 마우스 버튼 누름에 대응하는 임시 마우스 떼기 메시지이다.\r\n         * n번 마우스 버튼 떼기가 발생하면 messagePool[n]에 있는 메시지를 꺼내서 end 값을 입력하고 큐에 넣는다.\r\n         * */\r\n        this.messagePool = [];\r\n        this.mousedown = (ev) => {\r\n            ev.preventDefault();\r\n            if (this.listener.acceptCoordinate(ev.offsetX * this.scale, ev.offsetY * this.scale)) {\r\n                // pulse를 맞으면 currentX는 beforeX가 된다.\r\n                // 따라서 rAF가 발생하는 시점에서 이전 위치는 마우스 누름 위치로 간주된다.\r\n                this.currentX = ev.offsetX * this.scale;\r\n                this.currentY = ev.offsetY * this.scale;\r\n                // 이것과 rAF 사이에 move가 발생하지 않으면 rAF 발생 시 혀재 위치 또한 마우스 누름 위치가 된다.\r\n                // rAF 발생 전에 move가 먼저 발생하면 input값을 덮어써서 걔들이 current값이 되겠지?\r\n                this.inputX = ev.offsetX * this.scale;\r\n                this.inputY = ev.offsetY * this.scale;\r\n                this.source.addEventListener('mousemove', this.mousemove);\r\n                document.addEventListener('mouseup', this.mouseup);\r\n                // 마우스 누름 이벤트를 입력한다.\r\n                this.messages.push({\r\n                    type: \"mousedown\",\r\n                    startX: ev.offsetX * this.scale,\r\n                    startY: ev.offsetY * this.scale,\r\n                    startTime: ev.timeStamp\r\n                });\r\n                // down-up pair를 위해 마우스 누름 위치를 저장한다.\r\n                this.messagePool[ev.button] = {\r\n                    type: \"mouseup\",\r\n                    startX: ev.offsetX * this.scale,\r\n                    startY: ev.offsetY * this.scale,\r\n                    startTime: ev.timeStamp\r\n                };\r\n            }\r\n            return false;\r\n        };\r\n        this.mousemove = (ev) => {\r\n            this.inputX = ev.offsetX * this.scale;\r\n            this.inputY = ev.offsetY * this.scale;\r\n        };\r\n        this.mouseup = (ev) => {\r\n            /* MouseEvent.offsetX는 source 상대 위치이다. 띠용! */\r\n            let x = ev.offsetX * this.scale;\r\n            let y = ev.offsetY * this.scale;\r\n            // 마우스 누름 당시 저장했던 마우스 놓기 메시지를 가져온다.\r\n            let message = this.messagePool[ev.button];\r\n            delete this.messagePool[ev.button];\r\n            // 임시 메시지에 실제 마우스 놓기 데이터를 입력하여 메시지를 완성시킨다.\r\n            message.endX = x;\r\n            message.endY = y;\r\n            message.endTime = ev.timeStamp;\r\n            // 메시지를 큐에 입력한다.\r\n            this.messages.push(message);\r\n            // 현재 rAF의 마우스 위치를 떼기 위치로 간주한다.\r\n            // input에다 좌표를 넣어두면 rAF 발생 시 current로 내려가겠지?\r\n            this.inputX = x;\r\n            this.inputY = y;\r\n            this.source.removeEventListener('mousemove', this.mousemove);\r\n            document.removeEventListener('mouseup', this.mouseup);\r\n        };\r\n    }\r\n    /** 현재 마우스 위치 */\r\n    get x() { return this.currentX; }\r\n    get y() { return this.currentY; }\r\n    /** 마지막 update(rAF)가 발생하기 직전의 마우스 위치 */\r\n    get beforeX() { return this._beforeX; }\r\n    get beforeY() { return this._beforeY; }\r\n    /** update(rAF) 간의 x, y 변화량 */\r\n    get moveX() {\r\n        return (this.beforeX != null) && (this.currentX != null) ? (this.currentX - this._beforeX) : 0;\r\n    }\r\n    get moveY() {\r\n        return (this.beforeY != null) && (this.currentY != null) ? (this.currentY - this._beforeY) : 0;\r\n    }\r\n    /** 입력 컴포넌트를 뷰에 연결한다. */\r\n    connect(source, listener) {\r\n        this.disconnect();\r\n        this.source = source;\r\n        this.listener = listener;\r\n        this.source.addEventListener('mousedown', this.mousedown);\r\n    }\r\n    /** 입력 컴포넌트 연결을 해제한다. */\r\n    disconnect() {\r\n        let source = this.source;\r\n        if (source) {\r\n            source.removeEventListener('mousedown', this.mousedown);\r\n            source.removeEventListener('mousemove', this.mousemove);\r\n            document.removeEventListener('mouseup', this.mouseup);\r\n        }\r\n        this.source = null;\r\n        this.listener = null;\r\n    }\r\n    /**\r\n     * (rAF) 큐에 있는 메시지를 모두 정리하고, 상태를 전이시킨다.\r\n     *\r\n     * # 중요 : 디스패치는 currentX|Y, beforeX|Y, moveX|Y와는 좆도 상관 없다고 씨발놈아!!\r\n     * */\r\n    update() {\r\n        // dispatch\r\n        let message;\r\n        while ((message = this.messages.shift()) != null) {\r\n            switch (message.type) {\r\n                case \"mousedown\":\r\n                    this.listener.dispatchMousedown(message);\r\n                    break;\r\n                case \"mouseup\":\r\n                    this.listener.dispatchMouseup(message);\r\n                    break;\r\n            }\r\n        }\r\n        // pulse\r\n        this._beforeX = this.currentX;\r\n        this._beforeY = this.currentY;\r\n        this.currentX = this.inputX;\r\n        this.currentY = this.inputY;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSW5wdXQudHM/MzUzZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQztBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL0lucHV0LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIOuniOyasOyKpCDsnoXroKXsnYQg67Cb7JWE65Ok7Jes7IScIOumrOyKpOuEiOyXkOqyjCDsoITri6ztlZjripQg7YG0656Y7IqkXHJcbiAqIOydtCDtgbTrnpjsiqTripQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCnsnYQg7IKs7Jqp7ZWcIOyXheuNsOydtO2KuCDtjKjthLTsl5Ag7Yq57ZmU65CcIOq1rOyhsOulvCDqsIDsp4Dqs6Ag7J6I64ukLlxyXG4gKiDspJHsmpTtlZjqs6Ag7JaR7J20IOu5hOq1kOyggSDsoIHsnYAg7J2067Kk7Yq4KOuniOyasOyKpCDriITrpoQsIOuniOyasOyKpCDrhpPsnYwp64qUIOunpCDsnbTrsqTtirgg66Oo7ZSE66eI64ukIOuGk+y5mOyngCDslYrqs6Ag7Lqh7LOQ7ZW0IOuRkOqzoCwg7JWV64+E7KCB7Jy866GcIOunjuydtCDrsJzsg53tlZjqs6Ag7KSR7JqU7ZWY7KeAIOyViuydgCDsnbTrsqTtirgo66eI7Jqw7IqkIOybgOyngeyehCnripQg67OA7ZmU7JeQIOuUsOudvCBcIu2YhOyerCDsg4Htg5xcIuyZgCBcIuyngeyghCDsg4Htg5xcIuunjOydhCDsoIDsnqXtlbQg65GQ6rOgIHJBRuyXkOyEnCDqt7gg7IOB7YOc66W8IOywuOyhsO2VmOuPhOuhnSDtlZjqs6Ag7J6I64ukLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW91c2VJbnB1dCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKiog7KSR7JqUIOydtOuypO2KuCjrp4jsmrDsiqQg64iE66aELCDrp4jsmrDsiqQg64aT7J2MKeulvCDsoIDsnqXtlZwg7YGQICovXHJcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIC8qKiDslrTrlqQg7Luo7Yq466GkKO2Kue2eiCDrt7Ag6riw67CYIOy7qO2KuOuhpCnsl5AgXCLrsLDsnKjsnbQg7ISk7KCVXCLrkJjsl4jqs6AsIOumrOyKpOuEiOyXkOqyjCDrqqjrjbgg7KKM7ZGc6rOEIOq4sOuwmOycvOuhnCDrqZTsi5zsp4Drpbwg67O064K06rOgIOyLtuydhCDrlYwg66qo65OgIOydtOuypO2KuOyXkCDsnbQg6rCS7J20IOqzse2VtOynhOuLpC4gKi9cclxuICAgICAgICB0aGlzLnNjYWxlID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBET00g7J2067Kk7Yq46rCAIOuwnOyDne2WiOydhCDrlYwg7J6E7Iuc7KCB7Jy866GcIOy6oeyzkO2VnCDrp4jsmrDsiqQg7JyE7LmYXHJcbiAgICAgICAgICog7J206rKD7J2AIOydtOuPmSwg64iE66aELCDrhpPsnYwg66qo65OgIOyiheulmOydmCDsnbTrsqTtirjrpbwg67Cb7JWE65Ok7J2464ukXHJcbiAgICAgICAgICogTGlzdGVuZXLqsIAg66eI7Jqw7IqkIOyijO2RnOulvCDrsJvslYTrk6TsnbTrqbQg7Y287KaQIOyhsOqwgeyXkCDrsJTroZwg67CY7JiB7ZWY7KeAIOyViuqzoCwgcmVxdWVzdEFuaW1hdGlvbkZyYW1l7J20IOuPjOyVhOyYrCDrlYzquYzsp4Ag6riw64uk66aw64ukLiAo7J2067Kk7Yq4IO2VuOuTpOungeydtCByQUbrs7Tri6Qg7Zuo7JSsIOunjuydtCDrsJzsg53tlZzri6QuKVxyXG4gICAgICAgICAqIOuUsOudvOyEnCDsj5/slYTsp4DripQg7J2067Kk7Yq466GcIOyduO2VtCDrtojtlYTsmpTtlZjqsowg7ISx64ql7J20IOyggO2VmOuQmOuKlCDqsoPsnYQg67Cp7KeA7ZWc64ukLlxyXG4gICAgICAgICAqIOyWtOuWpCDsnbTrsqTtirgg66Oo7ZSE7JeQ7IScIHJBRuqwgCDrsJzsg53tlZjsp4Ag7JWK7Jy866m0IO2VtOuLuSDro6jtlITroZwg67Cb7JWE65Ok7J24IOyijO2RnOuKlCDrsoTroKTsp4Dqsowg65Cc64ukLlxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgdGhpcy5pbnB1dFggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5wdXRZID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpbnB1dFgsIGlucHV0WeuKlCDrk5zrnpjqt7jrpbwg7ZWY64qUIO2VnOyXkOyEnOuKlCDtmITsnqwg7JyE7LmY66GcIOyCrOyaqeuQoCDsiJgg7J6I7Jy864KYLFxyXG4gICAgICAgICAqIOuTnOuemOq3uOulvCDtlZjsp4Ag7JWK64qUIOuPmeyViOyXkOuKlCDrp4jsp4Drp4nsnLzroZwg66eI7Jqw7IqkIOydtOuypO2KuOqwgCDsnbzslrTrgpwg7KeA7KCQ7J20IOqzhOyGjSDsoIDsnqXrkJjslrQg7J6I64ukLlxyXG4gICAgICAgICAqIOqyjOuLpOqwgCB1cGRhdGUoKeyXkOyEnCBkaXNwYXRjaOyZgCBwdWxzZeuKlCDrp4jsmrDsiqQg64iM66a8IOyXrOu2gOyZgCDqtIDqs4Tsl4bsnbQg7ZWt7IOBIOyLpO2WieuQnOuLpC5cclxuICAgICAgICAgKiDrlLDrnbzshJwgaW5wdXRYLCBpbnB1dFnripQgXCLtmITsnqxcIuulvCDrgpjtg4DrgrTquLDsl5DripQg67aA7KCB7KCI7ZWY64ukLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50WCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50WSA9IG51bGw7XHJcbiAgICAgICAgLyoqIChwcml2YXRlKSDrp4jsp4Drp4kgdXBkYXRlKHJBRinqsIAg67Cc7IOd7ZWY6riwIOyngeyghOydmCDrp4jsmrDsiqQg7JyE7LmYICovXHJcbiAgICAgICAgdGhpcy5fYmVmb3JlWCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYmVmb3JlWSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog66eI7Jqw7IqkIOuIhOumhCDrsJzsg50g7IucLCDslrjsoKDqsIAg67Cc7IOd7ZWgIOuniOyasOyKpCDrlrzquLDsl5Ag64yA7J2R7ZWY7JesIOyehOyLnOuhnCDrqZTsi5zsp4Drpbwg66eM65Ok7Ja0IOyggOyepe2VtCDrkZgg67Cw7Je0XHJcbiAgICAgICAgICogbWVzc2FnZVBvb2xbbl3snYAgbuuyiCDrp4jsmrDsiqQg67KE7Yq8IOuIhOumhOyXkCDrjIDsnZHtlZjripQg7J6E7IucIOuniOyasOyKpCDrlrzquLAg66mU7Iuc7KeA7J2064ukLlxyXG4gICAgICAgICAqIG7rsogg66eI7Jqw7IqkIOuyhO2KvCDrlrzquLDqsIAg67Cc7IOd7ZWY66m0IG1lc3NhZ2VQb29sW25d7JeQIOyeiOuKlCDrqZTsi5zsp4Drpbwg6rq864K07IScIGVuZCDqsJLsnYQg7J6F66Cl7ZWY6rOgIO2BkOyXkCDrhKPripTri6QuXHJcbiAgICAgICAgICogKi9cclxuICAgICAgICB0aGlzLm1lc3NhZ2VQb29sID0gW107XHJcbiAgICAgICAgdGhpcy5tb3VzZWRvd24gPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXIuYWNjZXB0Q29vcmRpbmF0ZShldi5vZmZzZXRYICogdGhpcy5zY2FsZSwgZXYub2Zmc2V0WSAqIHRoaXMuc2NhbGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwdWxzZeulvCDrp57snLzrqbQgY3VycmVudFjripQgYmVmb3JlWOqwgCDrkJzri6QuXHJcbiAgICAgICAgICAgICAgICAvLyDrlLDrnbzshJwgckFG6rCAIOuwnOyDne2VmOuKlCDsi5zsoJDsl5DshJwg7J207KCEIOychOy5mOuKlCDrp4jsmrDsiqQg64iE66aEIOychOy5mOuhnCDqsITso7zrkJzri6QuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRYID0gZXYub2Zmc2V0WCAqIHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRZID0gZXYub2Zmc2V0WSAqIHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAvLyDsnbTqsoPqs7wgckFGIOyCrOydtOyXkCBtb3Zl6rCAIOuwnOyDne2VmOyngCDslYrsnLzrqbQgckFGIOuwnOyDnSDsi5wg7ZiA7J6sIOychOy5mCDrmJDtlZwg66eI7Jqw7IqkIOuIhOumhCDsnITsuZjqsIAg65Cc64ukLlxyXG4gICAgICAgICAgICAgICAgLy8gckFGIOuwnOyDnSDsoITsl5AgbW92ZeqwgCDrqLzsoIAg67Cc7IOd7ZWY66m0IGlucHV06rCS7J2EIOuNruyWtOyNqOyEnCDqsZTrk6TsnbQgY3VycmVudOqwkuydtCDrkJjqsqDsp4A/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0WCA9IGV2Lm9mZnNldFggKiB0aGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFkgPSBldi5vZmZzZXRZICogdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNldXApO1xyXG4gICAgICAgICAgICAgICAgLy8g66eI7Jqw7IqkIOuIhOumhCDsnbTrsqTtirjrpbwg7J6F66Cl7ZWc64ukLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm1vdXNlZG93blwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WDogZXYub2Zmc2V0WCAqIHRoaXMuc2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRZOiBldi5vZmZzZXRZICogdGhpcy5zY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGV2LnRpbWVTdGFtcFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBkb3duLXVwIHBhaXLrpbwg7JyE7ZW0IOuniOyasOyKpCDriITrpoQg7JyE7LmY66W8IOyggOyepe2VnOuLpC5cclxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZVBvb2xbZXYuYnV0dG9uXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm1vdXNldXBcIixcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFg6IGV2Lm9mZnNldFggKiB0aGlzLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WTogZXYub2Zmc2V0WSAqIHRoaXMuc2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBldi50aW1lU3RhbXBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5tb3VzZW1vdmUgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dFggPSBldi5vZmZzZXRYICogdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dFkgPSBldi5vZmZzZXRZICogdGhpcy5zY2FsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubW91c2V1cCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAvKiBNb3VzZUV2ZW50Lm9mZnNldFjripQgc291cmNlIOyDgeuMgCDsnITsuZjsnbTri6QuIOudoOyaqSEgKi9cclxuICAgICAgICAgICAgbGV0IHggPSBldi5vZmZzZXRYICogdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgbGV0IHkgPSBldi5vZmZzZXRZICogdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgLy8g66eI7Jqw7IqkIOuIhOumhCDri7nsi5wg7KCA7J6l7ZaI642YIOuniOyasOyKpCDrhpPquLAg66mU7Iuc7KeA66W8IOqwgOyguOyYqOuLpC5cclxuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VQb29sW2V2LmJ1dHRvbl07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1lc3NhZ2VQb29sW2V2LmJ1dHRvbl07XHJcbiAgICAgICAgICAgIC8vIOyehOyLnCDrqZTsi5zsp4Dsl5Ag7Iuk7KCcIOuniOyasOyKpCDrhpPquLAg642w7J207YSw66W8IOyeheugpe2VmOyXrCDrqZTsi5zsp4Drpbwg7JmE7ISx7Iuc7YKo64ukLlxyXG4gICAgICAgICAgICBtZXNzYWdlLmVuZFggPSB4O1xyXG4gICAgICAgICAgICBtZXNzYWdlLmVuZFkgPSB5O1xyXG4gICAgICAgICAgICBtZXNzYWdlLmVuZFRpbWUgPSBldi50aW1lU3RhbXA7XHJcbiAgICAgICAgICAgIC8vIOuplOyLnOyngOulvCDtgZDsl5Ag7J6F66Cl7ZWc64ukLlxyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIC8vIO2YhOyerCByQUbsnZgg66eI7Jqw7IqkIOychOy5mOulvCDrlrzquLAg7JyE7LmY66GcIOqwhOyjvO2VnOuLpC5cclxuICAgICAgICAgICAgLy8gaW5wdXTsl5Dri6Qg7KKM7ZGc66W8IOuEo+yWtOuRkOuptCByQUYg67Cc7IOdIOyLnCBjdXJyZW5066GcIOuCtOugpOqwgOqyoOyngD9cclxuICAgICAgICAgICAgdGhpcy5pbnB1dFggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0WSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKiDtmITsnqwg66eI7Jqw7IqkIOychOy5mCAqL1xyXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLmN1cnJlbnRYOyB9XHJcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuY3VycmVudFk7IH1cclxuICAgIC8qKiDrp4jsp4Drp4kgdXBkYXRlKHJBRinqsIAg67Cc7IOd7ZWY6riwIOyngeyghOydmCDrp4jsmrDsiqQg7JyE7LmYICovXHJcbiAgICBnZXQgYmVmb3JlWCgpIHsgcmV0dXJuIHRoaXMuX2JlZm9yZVg7IH1cclxuICAgIGdldCBiZWZvcmVZKCkgeyByZXR1cm4gdGhpcy5fYmVmb3JlWTsgfVxyXG4gICAgLyoqIHVwZGF0ZShyQUYpIOqwhOydmCB4LCB5IOuzgO2ZlOufiSAqL1xyXG4gICAgZ2V0IG1vdmVYKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5iZWZvcmVYICE9IG51bGwpICYmICh0aGlzLmN1cnJlbnRYICE9IG51bGwpID8gKHRoaXMuY3VycmVudFggLSB0aGlzLl9iZWZvcmVYKSA6IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgbW92ZVkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJlZm9yZVkgIT0gbnVsbCkgJiYgKHRoaXMuY3VycmVudFkgIT0gbnVsbCkgPyAodGhpcy5jdXJyZW50WSAtIHRoaXMuX2JlZm9yZVkpIDogMDtcclxuICAgIH1cclxuICAgIC8qKiDsnoXroKUg7Lu07Y+s64SM7Yq466W8IOu3sOyXkCDsl7DqsrDtlZzri6QuICovXHJcbiAgICBjb25uZWN0KHNvdXJjZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd24pO1xyXG4gICAgfVxyXG4gICAgLyoqIOyeheugpSDsu7Ttj6zrhIztirgg7Jew6rKw7J2EIO2VtOygnO2VnOuLpC4gKi9cclxuICAgIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xyXG4gICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duKTtcclxuICAgICAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogKHJBRikg7YGQ7JeQIOyeiOuKlCDrqZTsi5zsp4Drpbwg66qo65GQIOygleumrO2VmOqzoCwg7IOB7YOc66W8IOyghOydtOyLnO2CqOuLpC5cclxuICAgICAqXHJcbiAgICAgKiAjIOykkeyalCA6IOuUlOyKpO2MqOy5mOuKlCBjdXJyZW50WHxZLCBiZWZvcmVYfFksIG1vdmVYfFnsmYDripQg7KKG64+EIOyDgeq0gCDsl4bri6Tqs6Ag7JSo67Cc64aI7JWEISFcclxuICAgICAqICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgLy8gZGlzcGF0Y2hcclxuICAgICAgICBsZXQgbWVzc2FnZTtcclxuICAgICAgICB3aGlsZSAoKG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLnNoaWZ0KCkpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLmRpc3BhdGNoTW91c2Vkb3duKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLmRpc3BhdGNoTW91c2V1cChtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwdWxzZVxyXG4gICAgICAgIHRoaXMuX2JlZm9yZVggPSB0aGlzLmN1cnJlbnRYO1xyXG4gICAgICAgIHRoaXMuX2JlZm9yZVkgPSB0aGlzLmN1cnJlbnRZO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFggPSB0aGlzLmlucHV0WDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRZID0gdGhpcy5pbnB1dFk7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Input.ts\n");

/***/ }),

/***/ "./src/Physical.ts":
/*!*************************!*\
  !*** ./src/Physical.ts ***!
  \*************************/
/*! exports provided: willHit, clone, assign */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"willHit\", function() { return willHit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/** 두 개의 박스 a, b에 대해 어떠한 축 위에서의 **1차원 충돌**을 예측한다. */\r\nfunction willHit(a, b, direction) {\r\n    if (a == b)\r\n        return false;\r\n    let aStart;\r\n    let aEnd;\r\n    let bStart;\r\n    let bEnd;\r\n    if (direction == \"h\") {\r\n        aStart = Math.min(a.x, a.x + a.velX);\r\n        aEnd = Math.max(a.x + a.size, a.x + a.size + a.velX);\r\n        bStart = Math.min(b.x, b.x + b.velX);\r\n        bEnd = Math.max(b.x + b.size, b.x + b.size + b.velX);\r\n    }\r\n    else if (direction == \"v\") {\r\n        aStart = Math.min(a.y, a.y + a.velY);\r\n        aEnd = Math.max(a.y + a.size, a.y + a.size + a.velY);\r\n        bStart = Math.min(b.y, b.y + b.velY);\r\n        bEnd = Math.max(b.y + b.size, b.y + b.size + b.velY);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n    return aStart < bEnd && bStart < aEnd;\r\n}\r\n/** Physical의 속성을 가지고 있는 어떤 객체에서 Physical의 속성만을 뽑아내 복사한다. */\r\nfunction clone(src) {\r\n    let { x, y, size, velX, velY } = src;\r\n    return { x, y, size, velX, velY };\r\n}\r\n/** target의 각 Physical 속성이 src의 것과 같게 한다. */\r\nfunction assign(target, src) {\r\n    target.x = src.x;\r\n    target.y = src.y;\r\n    // 아직까진 모든 조각의 크기가 같으므로 생략한다.\r\n    // target.size = src.size\r\n    target.velX = src.velX;\r\n    target.velY = src.velY;\r\n}\r\nwindow.willHit = willHit;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUGh5c2ljYWwudHM/NGU4YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMseUJBQXlCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL1BoeXNpY2FsLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIOuRkCDqsJzsnZgg67CV7IqkIGEsIGLsl5Ag64yA7ZW0IOyWtOuWoO2VnCDstpUg7JyE7JeQ7ISc7J2YICoqMeywqOybkCDstqnrj4wqKuydhCDsmIjsuKHtlZzri6QuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3aWxsSGl0KGEsIGIsIGRpcmVjdGlvbikge1xyXG4gICAgaWYgKGEgPT0gYilcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgYVN0YXJ0O1xyXG4gICAgbGV0IGFFbmQ7XHJcbiAgICBsZXQgYlN0YXJ0O1xyXG4gICAgbGV0IGJFbmQ7XHJcbiAgICBpZiAoZGlyZWN0aW9uID09IFwiaFwiKSB7XHJcbiAgICAgICAgYVN0YXJ0ID0gTWF0aC5taW4oYS54LCBhLnggKyBhLnZlbFgpO1xyXG4gICAgICAgIGFFbmQgPSBNYXRoLm1heChhLnggKyBhLnNpemUsIGEueCArIGEuc2l6ZSArIGEudmVsWCk7XHJcbiAgICAgICAgYlN0YXJ0ID0gTWF0aC5taW4oYi54LCBiLnggKyBiLnZlbFgpO1xyXG4gICAgICAgIGJFbmQgPSBNYXRoLm1heChiLnggKyBiLnNpemUsIGIueCArIGIuc2l6ZSArIGIudmVsWCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT0gXCJ2XCIpIHtcclxuICAgICAgICBhU3RhcnQgPSBNYXRoLm1pbihhLnksIGEueSArIGEudmVsWSk7XHJcbiAgICAgICAgYUVuZCA9IE1hdGgubWF4KGEueSArIGEuc2l6ZSwgYS55ICsgYS5zaXplICsgYS52ZWxZKTtcclxuICAgICAgICBiU3RhcnQgPSBNYXRoLm1pbihiLnksIGIueSArIGIudmVsWSk7XHJcbiAgICAgICAgYkVuZCA9IE1hdGgubWF4KGIueSArIGIuc2l6ZSwgYi55ICsgYi5zaXplICsgYi52ZWxZKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBhU3RhcnQgPCBiRW5kICYmIGJTdGFydCA8IGFFbmQ7XHJcbn1cclxuLyoqIFBoeXNpY2Fs7J2YIOyGjeyEseydhCDqsIDsp4Dqs6Ag7J6I64qUIOyWtOuWpCDqsJ3ssrTsl5DshJwgUGh5c2ljYWzsnZgg7IaN7ISx66eM7J2EIOu9keyVhOuCtCDrs7XsgqztlZzri6QuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShzcmMpIHtcclxuICAgIGxldCB7IHgsIHksIHNpemUsIHZlbFgsIHZlbFkgfSA9IHNyYztcclxuICAgIHJldHVybiB7IHgsIHksIHNpemUsIHZlbFgsIHZlbFkgfTtcclxufVxyXG4vKiogdGFyZ2V07J2YIOqwgSBQaHlzaWNhbCDsho3shLHsnbQgc3Jj7J2YIOqyg+qzvCDqsJnqsowg7ZWc64ukLiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc3JjKSB7XHJcbiAgICB0YXJnZXQueCA9IHNyYy54O1xyXG4gICAgdGFyZ2V0LnkgPSBzcmMueTtcclxuICAgIC8vIOyVhOyngeq5jOynhCDrqqjrk6Ag7KGw6rCB7J2YIO2BrOq4sOqwgCDqsJnsnLzrr4DroZwg7IOd65617ZWc64ukLlxyXG4gICAgLy8gdGFyZ2V0LnNpemUgPSBzcmMuc2l6ZVxyXG4gICAgdGFyZ2V0LnZlbFggPSBzcmMudmVsWDtcclxuICAgIHRhcmdldC52ZWxZID0gc3JjLnZlbFk7XHJcbn1cclxud2luZG93LndpbGxIaXQgPSB3aWxsSGl0O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Physical.ts\n");

/***/ }),

/***/ "./src/Piece.ts":
/*!**********************!*\
  !*** ./src/Piece.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Piece; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\r\nconst AXIS = {\r\n    h: {\r\n        axis: 'x',\r\n        start: 'left',\r\n        end: 'right'\r\n    },\r\n    v: {\r\n        axis: 'y',\r\n        start: 'top',\r\n        end: 'bottom'\r\n    }\r\n};\r\nclass Piece {\r\n    constructor(tag, texture, srcX, srcY, srcD, viewD) {\r\n        /** 퍼즐 조각의 이동 속도 (업데이트에 이용된다. 아님 말고.) */\r\n        this.velX = 0;\r\n        this.velY = 0;\r\n        /** 퍼즐 조각이 혼자서 움직일 때 (마우스를 놓을 때) 퍼즐 조각이 이동하는 경로 */\r\n        this.destX = null;\r\n        this.destY = null;\r\n        this.tag = tag;\r\n        this.texture = texture;\r\n        this.sx = srcX;\r\n        this.sy = srcY;\r\n        this.srcSize = srcD;\r\n        this.size = viewD;\r\n    }\r\n    /** 퍼즐 조각의 목표 위치/현재 위치를 기반으로 퍼즐의 행렬 위치를 찾아낸다. */\r\n    whereami(left, top, boardSize, divideBy) {\r\n        let x = (this.destX != null ? this.destX : this.x) + this.size / 2;\r\n        let y = (this.destY != null ? this.destY : this.y) + this.size / 2;\r\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getRowCol\"])(x, y, boardSize, left, top, divideBy);\r\n    }\r\n    /**\r\n     * 퍼즐 조각을 한 방향으로 움직이기만 한다.\r\n     * 위에 것과는 다르게 재귀를 사용하지 않는다.\r\n     */\r\n    move(dist, direction, game, concern) {\r\n        const { axis, start, end } = AXIS[direction];\r\n    }\r\n    /**\r\n     * 업데이트한다.\r\n     * 빈칸을 나타내는 조각은 업데이트되지 않는다.\r\n     *\r\n     * 일단, 업데이트 자체는 드래그 여부와 상관없이 모든 조각에 대해 항상 실행된다.\r\n    */\r\n    update(game) {\r\n        // (참고 : 마우스 버튼을 누르는 순간 모든 조각의 destX, destY가 null이 되고 velX, velY 또한 0이 되므로 조각을 드래그하는 중에는 이 블록과 저 아래에 destY 블록까지 무시된다.)\r\n        // 아직 목표 x위치에 도달하지 않았다면\r\n        if (this.destX != null) {\r\n            let distX = this.destX - this.x;\r\n            // 목표 위치에 도달할 수 있도록 속도를 설정해준다.\r\n            this.velX = this.size / 6 * Math.sign(distX);\r\n            // 조각이 목표에 충분히 가까이 접근했다면 목표 위치에 안착시키고, 속도를 없앤다.\r\n            if ((Math.abs(distX) < Math.abs(this.velX)) || (Math.abs(distX) < 0.1)) {\r\n                this.x = this.destX;\r\n                this.destX = null;\r\n                if (Math.abs(this.velX) >= 3) {\r\n                    // tick!\r\n                }\r\n                this.velX = 0;\r\n            }\r\n        }\r\n        if (this.destY != null) {\r\n            let distY = this.destY - this.y;\r\n            this.velY = this.size / 6 * Math.sign(distY);\r\n            if ((Math.abs(distY) < Math.abs(this.velY)) || (Math.abs(distY) < 0.1)) {\r\n                this.y = this.destY;\r\n                this.destY = null;\r\n                if (Math.abs(this.velY) >= 3) {\r\n                    // tick!\r\n                }\r\n                this.velY = 0;\r\n            }\r\n        }\r\n        this.x += this.velX;\r\n        this.y += this.velY;\r\n        if (this.x < game.left) {\r\n            this.x = game.left;\r\n            this.velX = 0;\r\n        }\r\n        else if (this.x + this.size > game.right) {\r\n            this.x = game.right - this.size;\r\n            this.velX = 0;\r\n        }\r\n        if (this.y < game.top) {\r\n            this.y = game.top;\r\n            this.velY = 0;\r\n        }\r\n        else if (this.y + this.size > game.bottom) {\r\n            this.y = game.bottom - this.size;\r\n            this.velY = 0;\r\n        }\r\n    }\r\n    /**\r\n     * 렌더링한다.\r\n     * 빈칸을 나타내는 조각에 대해서는 메서드가 아예 실행되지 않는다.\r\n     */\r\n    render(context, showLabel = true) {\r\n        context.fillStyle = 'white';\r\n        context.lineWidth = 1;\r\n        context.strokeRect(this.x, this.y, this.size, this.size);\r\n        context.fillRect(this.x, this.y, this.size, this.size);\r\n        context.drawImage(this.texture, this.sx, this.sy, this.srcSize, this.srcSize, this.x, this.y, this.size, this.size);\r\n        if (showLabel) {\r\n            let fontSize = Math.floor(this.size / 3);\r\n            context.font = fontSize + 'px \"Exo 2\"';\r\n            context.lineWidth = 3;\r\n            let { width } = context.measureText(this.label);\r\n            let x = this.x + width / 2 + 4;\r\n            let y = this.y + this.size / 6 + 2;\r\n            context.strokeText(this.label, x, y);\r\n            context.fillText(this.label, x, y);\r\n        }\r\n    }\r\n    /**\r\n     * 퍼즐 조각을 목표 위치로 즉시 이동시키고, 속도를 없앤다.\r\n     */\r\n    getIntoPositionNow() {\r\n        if (this.destX != null) {\r\n            this.x = this.destX;\r\n            this.destX = null;\r\n            this.velX = 0;\r\n        }\r\n        if (this.destY != null) {\r\n            this.y = this.destY;\r\n            this.destY = null;\r\n            this.velY = 0;\r\n        }\r\n    }\r\n    /** x에서 x + velX로 또는 y에서 y + velY로 이동하는 경로에 부딪힐 다른 조각들이 있는지 판단한다. */\r\n    willHit(concern, direction) {\r\n        let vector = [];\r\n        if (direction == \"h\") {\r\n            for (const piece of concern) {\r\n                // if (piece.physical.x + piece.physical.size )\r\n            }\r\n        }\r\n        else if (direction == \"v\") {\r\n        }\r\n        return vector;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUGllY2UudHM/NTE3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvUGllY2UudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRSb3dDb2wgfSBmcm9tIFwiLi91dGlsc1wiO1xyXG5jb25zdCBBWElTID0ge1xyXG4gICAgaDoge1xyXG4gICAgICAgIGF4aXM6ICd4JyxcclxuICAgICAgICBzdGFydDogJ2xlZnQnLFxyXG4gICAgICAgIGVuZDogJ3JpZ2h0J1xyXG4gICAgfSxcclxuICAgIHY6IHtcclxuICAgICAgICBheGlzOiAneScsXHJcbiAgICAgICAgc3RhcnQ6ICd0b3AnLFxyXG4gICAgICAgIGVuZDogJ2JvdHRvbSdcclxuICAgIH1cclxufTtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGllY2Uge1xyXG4gICAgY29uc3RydWN0b3IodGFnLCB0ZXh0dXJlLCBzcmNYLCBzcmNZLCBzcmNELCB2aWV3RCkge1xyXG4gICAgICAgIC8qKiDtjbzsppAg7KGw6rCB7J2YIOydtOuPmSDsho3rj4QgKOyXheuNsOydtO2KuOyXkCDsnbTsmqnrkJzri6QuIOyVhOuLmCDrp5Dqs6AuKSAqL1xyXG4gICAgICAgIHRoaXMudmVsWCA9IDA7XHJcbiAgICAgICAgdGhpcy52ZWxZID0gMDtcclxuICAgICAgICAvKiog7Y287KaQIOyhsOqwgeydtCDtmLzsnpDshJwg7JuA7KeB7J28IOuVjCAo66eI7Jqw7Iqk66W8IOuGk+ydhCDrlYwpIO2NvOymkCDsobDqsIHsnbQg7J2064+Z7ZWY64qUIOqyveuhnCAqL1xyXG4gICAgICAgIHRoaXMuZGVzdFggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVzdFkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgdGhpcy5zeCA9IHNyY1g7XHJcbiAgICAgICAgdGhpcy5zeSA9IHNyY1k7XHJcbiAgICAgICAgdGhpcy5zcmNTaXplID0gc3JjRDtcclxuICAgICAgICB0aGlzLnNpemUgPSB2aWV3RDtcclxuICAgIH1cclxuICAgIC8qKiDtjbzsppAg7KGw6rCB7J2YIOuqqe2RnCDsnITsuZgv7ZiE7J6sIOychOy5mOulvCDquLDrsJjsnLzroZwg7Y287KaQ7J2YIO2WieugrCDsnITsuZjrpbwg7LC+7JWE64K464ukLiAqL1xyXG4gICAgd2hlcmVhbWkobGVmdCwgdG9wLCBib2FyZFNpemUsIGRpdmlkZUJ5KSB7XHJcbiAgICAgICAgbGV0IHggPSAodGhpcy5kZXN0WCAhPSBudWxsID8gdGhpcy5kZXN0WCA6IHRoaXMueCkgKyB0aGlzLnNpemUgLyAyO1xyXG4gICAgICAgIGxldCB5ID0gKHRoaXMuZGVzdFkgIT0gbnVsbCA/IHRoaXMuZGVzdFkgOiB0aGlzLnkpICsgdGhpcy5zaXplIC8gMjtcclxuICAgICAgICByZXR1cm4gZ2V0Um93Q29sKHgsIHksIGJvYXJkU2l6ZSwgbGVmdCwgdG9wLCBkaXZpZGVCeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIO2NvOymkCDsobDqsIHsnYQg7ZWcIOuwqe2WpeycvOuhnCDsm4Dsp4HsnbTquLDrp4wg7ZWc64ukLlxyXG4gICAgICog7JyE7JeQIOqyg+qzvOuKlCDri6TrpbTqsowg7J6s6reA66W8IOyCrOyaqe2VmOyngCDslYrripTri6QuXHJcbiAgICAgKi9cclxuICAgIG1vdmUoZGlzdCwgZGlyZWN0aW9uLCBnYW1lLCBjb25jZXJuKSB7XHJcbiAgICAgICAgY29uc3QgeyBheGlzLCBzdGFydCwgZW5kIH0gPSBBWElTW2RpcmVjdGlvbl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOyXheuNsOydtO2KuO2VnOuLpC5cclxuICAgICAqIOu5iOy5uOydhCDrgpjtg4DrgrTripQg7KGw6rCB7J2AIOyXheuNsOydtO2KuOuQmOyngCDslYrripTri6QuXHJcbiAgICAgKlxyXG4gICAgICog7J2864uoLCDsl4XrjbDsnbTtirgg7J6Q7LK064qUIOuTnOuemOq3uCDsl6zrtoDsmYAg7IOB6rSA7JeG7J20IOuqqOuToCDsobDqsIHsl5Ag64yA7ZW0IO2VreyDgSDsi6TtlonrkJzri6QuXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlKGdhbWUpIHtcclxuICAgICAgICAvLyAo7LC46rOgIDog66eI7Jqw7IqkIOuyhO2KvOydhCDriITrpbTripQg7Iic6rCEIOuqqOuToCDsobDqsIHsnZggZGVzdFgsIGRlc3RZ6rCAIG51bGzsnbQg65CY6rOgIHZlbFgsIHZlbFkg65iQ7ZWcIDDsnbQg65CY66+A66GcIOyhsOqwgeydhCDrk5zrnpjqt7jtlZjripQg7KSR7JeQ64qUIOydtCDruJTroZ3qs7wg7KCAIOyVhOuemOyXkCBkZXN0WSDruJTroZ3quYzsp4Ag66y07Iuc65Cc64ukLilcclxuICAgICAgICAvLyDslYTsp4Eg66qp7ZGcIHjsnITsuZjsl5Ag64+E64us7ZWY7KeAIOyViuyVmOuLpOuptFxyXG4gICAgICAgIGlmICh0aGlzLmRlc3RYICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IGRpc3RYID0gdGhpcy5kZXN0WCAtIHRoaXMueDtcclxuICAgICAgICAgICAgLy8g66qp7ZGcIOychOy5mOyXkCDrj4Tri6ztlaAg7IiYIOyeiOuPhOuhnSDsho3rj4Trpbwg7ISk7KCV7ZW07KSA64ukLlxyXG4gICAgICAgICAgICB0aGlzLnZlbFggPSB0aGlzLnNpemUgLyA2ICogTWF0aC5zaWduKGRpc3RYKTtcclxuICAgICAgICAgICAgLy8g7KGw6rCB7J20IOuqqe2RnOyXkCDstqnrtoTtnogg6rCA6rmM7J20IOygkeq3vO2WiOuLpOuptCDrqqntkZwg7JyE7LmY7JeQIOyViOywqeyLnO2CpOqzoCwg7IaN64+E66W8IOyXhuyVpOuLpC5cclxuICAgICAgICAgICAgaWYgKChNYXRoLmFicyhkaXN0WCkgPCBNYXRoLmFicyh0aGlzLnZlbFgpKSB8fCAoTWF0aC5hYnMoZGlzdFgpIDwgMC4xKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5kZXN0WDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdFggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMudmVsWCkgPj0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRpY2shXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbFggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRlc3RZICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IGRpc3RZID0gdGhpcy5kZXN0WSAtIHRoaXMueTtcclxuICAgICAgICAgICAgdGhpcy52ZWxZID0gdGhpcy5zaXplIC8gNiAqIE1hdGguc2lnbihkaXN0WSk7XHJcbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnMoZGlzdFkpIDwgTWF0aC5hYnModGhpcy52ZWxZKSkgfHwgKE1hdGguYWJzKGRpc3RZKSA8IDAuMSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuZGVzdFk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RZID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnZlbFkpID49IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aWNrIVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxZID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xyXG4gICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XHJcbiAgICAgICAgaWYgKHRoaXMueCA8IGdhbWUubGVmdCkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBnYW1lLmxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMudmVsWCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMueCArIHRoaXMuc2l6ZSA+IGdhbWUucmlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gZ2FtZS5yaWdodCAtIHRoaXMuc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy52ZWxYID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMueSA8IGdhbWUudG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IGdhbWUudG9wO1xyXG4gICAgICAgICAgICB0aGlzLnZlbFkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnkgKyB0aGlzLnNpemUgPiBnYW1lLmJvdHRvbSkge1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBnYW1lLmJvdHRvbSAtIHRoaXMuc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy52ZWxZID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOugjOuNlOunge2VnOuLpC5cclxuICAgICAqIOu5iOy5uOydhCDrgpjtg4DrgrTripQg7KGw6rCB7JeQIOuMgO2VtOyEnOuKlCDrqZTshJzrk5zqsIAg7JWE7JiIIOyLpO2WieuQmOyngCDslYrripTri6QuXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcihjb250ZXh0LCBzaG93TGFiZWwgPSB0cnVlKSB7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLCB0aGlzLnN4LCB0aGlzLnN5LCB0aGlzLnNyY1NpemUsIHRoaXMuc3JjU2l6ZSwgdGhpcy54LCB0aGlzLnksIHRoaXMuc2l6ZSwgdGhpcy5zaXplKTtcclxuICAgICAgICBpZiAoc2hvd0xhYmVsKSB7XHJcbiAgICAgICAgICAgIGxldCBmb250U2l6ZSA9IE1hdGguZmxvb3IodGhpcy5zaXplIC8gMyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTaXplICsgJ3B4IFwiRXhvIDJcIic7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMztcclxuICAgICAgICAgICAgbGV0IHsgd2lkdGggfSA9IGNvbnRleHQubWVhc3VyZVRleHQodGhpcy5sYWJlbCk7XHJcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy54ICsgd2lkdGggLyAyICsgNDtcclxuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnkgKyB0aGlzLnNpemUgLyA2ICsgMjtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRoaXMubGFiZWwsIHgsIHkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMubGFiZWwsIHgsIHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog7Y287KaQIOyhsOqwgeydhCDrqqntkZwg7JyE7LmY66GcIOymieyLnCDsnbTrj5nsi5ztgqTqs6AsIOyGjeuPhOulvCDsl4bslaTri6QuXHJcbiAgICAgKi9cclxuICAgIGdldEludG9Qb3NpdGlvbk5vdygpIHtcclxuICAgICAgICBpZiAodGhpcy5kZXN0WCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuZGVzdFg7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdFggPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnZlbFggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZXN0WSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuZGVzdFk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdFkgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnZlbFkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiB47JeQ7IScIHggKyB2ZWxY66GcIOuYkOuKlCB57JeQ7IScIHkgKyB2ZWxZ66GcIOydtOuPme2VmOuKlCDqsr3roZzsl5Ag67aA65Sq7Z6QIOuLpOuluCDsobDqsIHrk6TsnbQg7J6I64qU7KeAIO2MkOuLqO2VnOuLpC4gKi9cclxuICAgIHdpbGxIaXQoY29uY2VybiwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IHZlY3RvciA9IFtdO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJoXCIpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiBjb25jZXJuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAocGllY2UucGh5c2ljYWwueCArIHBpZWNlLnBoeXNpY2FsLnNpemUgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBcInZcIikge1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Piece.ts\n");

/***/ }),

/***/ "./src/PuzzleSet.ts":
/*!**************************!*\
  !*** ./src/PuzzleSet.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PuzzleSet; });\n/**\r\n * PuzzleSet은 그림, 정사각형 영역, 해결 가능 여부를 모아놓은 것이다.\r\n * 행이나 열을 뒤집는 기능 따위는 없다.\r\n */\r\nclass PuzzleSet {\r\n    /**\r\n     * 행, 열 번호로 이미지에서 참조할 좌표를 찾는다.\r\n     */\r\n    getPosition(row, col, divideBy) {\r\n        let d = this.size / divideBy;\r\n        return [this.left + col * d, this.top + row * d];\r\n    }\r\n    waitForImageLoad() {\r\n        this.texture = new Image();\r\n        this.texture.src = '/img/' + this.img;\r\n        if (this.texture.complete) {\r\n            return Promise.resolve();\r\n        }\r\n        return new Promise((a, b) => {\r\n            this.texture.onload = ev => {\r\n                a();\r\n            };\r\n            this.texture.onerror = b;\r\n        });\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUHV6emxlU2V0LnRzP2VmMjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsImZpbGUiOiIuL3NyYy9QdXp6bGVTZXQudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUHV6emxlU2V07J2AIOq3uOumvCwg7KCV7IKs6rCB7ZiVIOyYgeyXrSwg7ZW06rKwIOqwgOuKpSDsl6zrtoDrpbwg66qo7JWE64aT7J2AIOqyg+ydtOuLpC5cclxuICog7ZaJ7J2064KYIOyXtOydhCDrkqTsp5HripQg6riw64qlIOuUsOychOuKlCDsl4bri6QuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXp6bGVTZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiDtloksIOyXtCDrsojtmLjroZwg7J2066+47KeA7JeQ7IScIOywuOyhsO2VoCDsooztkZzrpbwg7LC+64qU64ukLlxyXG4gICAgICovXHJcbiAgICBnZXRQb3NpdGlvbihyb3csIGNvbCwgZGl2aWRlQnkpIHtcclxuICAgICAgICBsZXQgZCA9IHRoaXMuc2l6ZSAvIGRpdmlkZUJ5O1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5sZWZ0ICsgY29sICogZCwgdGhpcy50b3AgKyByb3cgKiBkXTtcclxuICAgIH1cclxuICAgIHdhaXRGb3JJbWFnZUxvYWQoKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLnNyYyA9ICcvaW1nLycgKyB0aGlzLmltZztcclxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5vbmxvYWQgPSBldiA9PiB7XHJcbiAgICAgICAgICAgICAgICBhKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5vbmVycm9yID0gYjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/PuzzleSet.ts\n");

/***/ }),

/***/ "./src/RAFPulseClock.ts":
/*!******************************!*\
  !*** ./src/RAFPulseClock.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RAFPulseClock; });\nclass RAFPulseClock {\r\n    constructor(update) {\r\n        this.running = false;\r\n        this.a = null;\r\n        this.update = update;\r\n    }\r\n    run() {\r\n        this.running = true;\r\n        this.a = (t) => {\r\n            this.update(t);\r\n            if (this.running) {\r\n                requestAnimationFrame(this.a);\r\n            }\r\n        };\r\n        requestAnimationFrame(this.a);\r\n    }\r\n    stop() {\r\n        this.running = false;\r\n        this.a = null;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUkFGUHVsc2VDbG9jay50cz8zY2M2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvUkFGUHVsc2VDbG9jay50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJBRlB1bHNlQ2xvY2sge1xyXG4gICAgY29uc3RydWN0b3IodXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcclxuICAgIH1cclxuICAgIHJ1bigpIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYSA9ICh0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYSk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYSA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/RAFPulseClock.ts\n");

/***/ }),

/***/ "./src/Timer.ts":
/*!**********************!*\
  !*** ./src/Timer.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Timer; });\n/** 마이크로초를 mm : ss . ss 로 나눈다. */\r\nfunction formatMs(ms) {\r\n    let val = Math.round(ms / 10);\r\n    let min = Math.floor(val / 6000);\r\n    let centisec = val % 6000;\r\n    let centisec_str = centisec.toString();\r\n    let centisec_len = centisec_str.length;\r\n    if (centisec_len < 4) {\r\n        let a = Array(4 - centisec_len);\r\n        a.fill('0');\r\n        centisec_str = a.join('') + centisec_str;\r\n    }\r\n    let min_str = min.toString();\r\n    let min_len = min_str.length;\r\n    if (min_len < 2) {\r\n        let a = Array(2 - min_len);\r\n        a.fill('0');\r\n        min_str = a.join('') + min_str;\r\n    }\r\n    return [min_str, centisec_str.substr(0, 2), centisec_str.substr(2, 2)];\r\n}\r\n/**\r\n * 타이머 컴포넌트\r\n * DOMHighResTimestamp 때문에 로직이 은근 복잡하다.\r\n * */\r\nclass Timer {\r\n    constructor() {\r\n        /** 시작 버튼을 누른 시각 */\r\n        this.startTime = null;\r\n        /** 퍼즐이 중단된 시각 */\r\n        this.endTime = null;\r\n        /** rAF에 의해 입력되는 시각 */\r\n        this.currentTime = 0;\r\n    }\r\n    set width(v) {\r\n        this._width = v;\r\n        this.w_3 = v / 3;\r\n        this.w_6 = v / 6;\r\n        this.p = this.w_6 - v / 25;\r\n        this.q = this.w_6 + v / 25;\r\n    }\r\n    start(startTime) {\r\n        this.startTime = startTime;\r\n        this.endTime = null;\r\n    }\r\n    end(endTime) {\r\n        this.endTime = endTime;\r\n    }\r\n    reset() {\r\n        this.startTime = null;\r\n        this.endTime = null;\r\n        this.currentTime = null;\r\n    }\r\n    update(t) {\r\n        this.currentTime = t;\r\n    }\r\n    render(context) {\r\n        let { y, left, w_3, w_6, p, q } = this;\r\n        context.font = this.fontSize + 'px \"Exo 2\"';\r\n        let [min, sec, cs] = formatMs(this.currentTime - this.startTime);\r\n        context.lineWidth = 4;\r\n        context.strokeText(min, left + w_6, y);\r\n        context.fillText(min, left + w_6, y);\r\n        context.strokeText('\\'', left + w_3, y);\r\n        context.fillText('\\'', left + w_3, y);\r\n        context.strokeText(sec[0], left + w_3 + p, y);\r\n        context.fillText(sec[0], left + w_3 + p, y);\r\n        context.strokeText(sec[1], left + w_3 + q, y);\r\n        context.fillText(sec[1], left + w_3 + q, y);\r\n        context.strokeText('\"', left + w_3 * 2, y);\r\n        context.fillText('\"', left + w_3 * 2, y);\r\n        context.strokeText(cs[0], left + w_3 * 2 + p, y);\r\n        context.fillText(cs[0], left + w_3 * 2 + p, y);\r\n        context.strokeText(cs[1], left + w_3 * 2 + q, y);\r\n        context.fillText(cs[1], left + w_3 * 2 + q, y);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVGltZXIudHM/OGJjNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvVGltZXIudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiog66eI7J207YGs66Gc7LSI66W8IG1tIDogc3MgLiBzcyDroZwg64KY64iI64ukLiAqL1xyXG5mdW5jdGlvbiBmb3JtYXRNcyhtcykge1xyXG4gICAgbGV0IHZhbCA9IE1hdGgucm91bmQobXMgLyAxMCk7XHJcbiAgICBsZXQgbWluID0gTWF0aC5mbG9vcih2YWwgLyA2MDAwKTtcclxuICAgIGxldCBjZW50aXNlYyA9IHZhbCAlIDYwMDA7XHJcbiAgICBsZXQgY2VudGlzZWNfc3RyID0gY2VudGlzZWMudG9TdHJpbmcoKTtcclxuICAgIGxldCBjZW50aXNlY19sZW4gPSBjZW50aXNlY19zdHIubGVuZ3RoO1xyXG4gICAgaWYgKGNlbnRpc2VjX2xlbiA8IDQpIHtcclxuICAgICAgICBsZXQgYSA9IEFycmF5KDQgLSBjZW50aXNlY19sZW4pO1xyXG4gICAgICAgIGEuZmlsbCgnMCcpO1xyXG4gICAgICAgIGNlbnRpc2VjX3N0ciA9IGEuam9pbignJykgKyBjZW50aXNlY19zdHI7XHJcbiAgICB9XHJcbiAgICBsZXQgbWluX3N0ciA9IG1pbi50b1N0cmluZygpO1xyXG4gICAgbGV0IG1pbl9sZW4gPSBtaW5fc3RyLmxlbmd0aDtcclxuICAgIGlmIChtaW5fbGVuIDwgMikge1xyXG4gICAgICAgIGxldCBhID0gQXJyYXkoMiAtIG1pbl9sZW4pO1xyXG4gICAgICAgIGEuZmlsbCgnMCcpO1xyXG4gICAgICAgIG1pbl9zdHIgPSBhLmpvaW4oJycpICsgbWluX3N0cjtcclxuICAgIH1cclxuICAgIHJldHVybiBbbWluX3N0ciwgY2VudGlzZWNfc3RyLnN1YnN0cigwLCAyKSwgY2VudGlzZWNfc3RyLnN1YnN0cigyLCAyKV07XHJcbn1cclxuLyoqXHJcbiAqIO2DgOydtOuouCDsu7Ttj6zrhIztirhcclxuICogRE9NSGlnaFJlc1RpbWVzdGFtcCDrlYzrrLjsl5Ag66Gc7KeB7J20IOydgOq3vCDrs7XsnqHtlZjri6QuXHJcbiAqICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKiDsi5zsnpEg67KE7Yq87J2EIOuIhOuluCDsi5zqsIEgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XHJcbiAgICAgICAgLyoqIO2NvOymkOydtCDspJHri6jrkJwg7Iuc6rCBICovXHJcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcclxuICAgICAgICAvKiogckFG7JeQIOydmO2VtCDsnoXroKXrkJjripQg7Iuc6rCBICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XHJcbiAgICB9XHJcbiAgICBzZXQgd2lkdGgodikge1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdjtcclxuICAgICAgICB0aGlzLndfMyA9IHYgLyAzO1xyXG4gICAgICAgIHRoaXMud182ID0gdiAvIDY7XHJcbiAgICAgICAgdGhpcy5wID0gdGhpcy53XzYgLSB2IC8gMjU7XHJcbiAgICAgICAgdGhpcy5xID0gdGhpcy53XzYgKyB2IC8gMjU7XHJcbiAgICB9XHJcbiAgICBzdGFydChzdGFydFRpbWUpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcclxuICAgICAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZW5kKGVuZFRpbWUpIHtcclxuICAgICAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0O1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgeyB5LCBsZWZ0LCB3XzMsIHdfNiwgcCwgcSB9ID0gdGhpcztcclxuICAgICAgICBjb250ZXh0LmZvbnQgPSB0aGlzLmZvbnRTaXplICsgJ3B4IFwiRXhvIDJcIic7XHJcbiAgICAgICAgbGV0IFttaW4sIHNlYywgY3NdID0gZm9ybWF0TXModGhpcy5jdXJyZW50VGltZSAtIHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDQ7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KG1pbiwgbGVmdCArIHdfNiwgeSk7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChtaW4sIGxlZnQgKyB3XzYsIHkpO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCgnXFwnJywgbGVmdCArIHdfMywgeSk7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCgnXFwnJywgbGVmdCArIHdfMywgeSk7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHNlY1swXSwgbGVmdCArIHdfMyArIHAsIHkpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoc2VjWzBdLCBsZWZ0ICsgd18zICsgcCwgeSk7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHNlY1sxXSwgbGVmdCArIHdfMyArIHEsIHkpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoc2VjWzFdLCBsZWZ0ICsgd18zICsgcSwgeSk7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCdcIicsIGxlZnQgKyB3XzMgKiAyLCB5KTtcclxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCdcIicsIGxlZnQgKyB3XzMgKiAyLCB5KTtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoY3NbMF0sIGxlZnQgKyB3XzMgKiAyICsgcCwgeSk7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChjc1swXSwgbGVmdCArIHdfMyAqIDIgKyBwLCB5KTtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoY3NbMV0sIGxlZnQgKyB3XzMgKiAyICsgcSwgeSk7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChjc1sxXSwgbGVmdCArIHdfMyAqIDIgKyBxLCB5KTtcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Timer.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _PuzzleSet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PuzzleSet */ \"./src/PuzzleSet.ts\");\n/* harmony import */ var _RAFPulseClock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RAFPulseClock */ \"./src/RAFPulseClock.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game */ \"./src/Game.ts\");\n/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Input */ \"./src/Input.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nlet game;\r\nlet clock;\r\nlet input;\r\nconst [gameCanvas, previewCanvas] = document.getElementsByTagName('canvas');\r\nconst gameContext = gameCanvas.getContext('2d');\r\nconst previewContext = previewCanvas.getContext('2d');\r\ngameContext.textAlign = 'center';\r\ngameContext.textBaseline = 'middle';\r\nconst horizontalMargin = 20;\r\nconst verticalMargin = 20;\r\nconst boardLength = gameCanvas.width - horizontalMargin * 2;\r\nconst timerHeight = gameCanvas.height / 5;\r\nconst sizeInput = document.getElementById('size');\r\nconst puzzleSelector = document.getElementById('puzzle-selector');\r\nconst startButton = document.getElementById('start');\r\nconst stopButton = document.getElementById('stop');\r\nconst blankPositionSelector = {\r\n    topLeft: document.getElementById('blank-pos-top-left'),\r\n    topRight: document.getElementById('blank-pos-top-right'),\r\n    bottomLeft: document.getElementById('blank-pos-bottom-left'),\r\n    bottomRight: document.getElementById('blank-pos-bottom-right'),\r\n};\r\nfunction decodeBlank() {\r\n    return [\r\n        blankPositionSelector.bottomLeft.checked || blankPositionSelector.bottomRight.checked,\r\n        blankPositionSelector.topRight.checked || blankPositionSelector.bottomRight.checked\r\n    ];\r\n}\r\nconst labelSelector = {\r\n    none: document.getElementById('show-label-none'),\r\n    phone: document.getElementById('show-label-phone'),\r\n    keypad: document.getElementById('show-label-keypad')\r\n};\r\nfunction loadPuzzleSets() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const puzzleSets = [];\r\n        const response = yield fetch('puzzleset.json');\r\n        const puzzleSetDataArray = yield response.json();\r\n        for (let i = 0; i < puzzleSetDataArray.length; i++) {\r\n            const puzzleSet = puzzleSetDataArray[i];\r\n            puzzleSet.__proto__ = _PuzzleSet__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype;\r\n            puzzleSets.push(puzzleSet);\r\n            const selectOption = document.createElement('option');\r\n            selectOption.value = i.toString();\r\n            selectOption.innerText = puzzleSet.title;\r\n            puzzleSelector.appendChild(selectOption);\r\n        }\r\n        yield Promise.all(puzzleSets.map(v => v.waitForImageLoad()));\r\n        return puzzleSets;\r\n    });\r\n}\r\nfunction resetButtons() {\r\n    startButton.innerText = '시작하기';\r\n    stopButton.disabled = true;\r\n}\r\nfunction setSizeHandler() {\r\n    game.setSize(sizeInput.valueAsNumber, ...decodeBlank());\r\n    resetButtons();\r\n}\r\nfunction renderPreview({ texture, left, top, size }) {\r\n    let { width, height } = previewCanvas;\r\n    previewContext.clearRect(0, 0, width, height);\r\n    previewContext.drawImage(texture, left, top, size, size, horizontalMargin, verticalMargin, width - horizontalMargin * 2, height - verticalMargin * 2);\r\n}\r\nloadPuzzleSets().then((puzzleSets) => {\r\n    startButton.addEventListener('click', ev => {\r\n        game.shuffle();\r\n        game.initPiecePosition();\r\n        game.start(ev.timeStamp);\r\n        startButton.innerText = '다시하기';\r\n        stopButton.disabled = false;\r\n    });\r\n    stopButton.addEventListener('click', ev => {\r\n        game.end(ev.timeStamp);\r\n        resetButtons();\r\n    });\r\n    blankPositionSelector.topLeft.addEventListener('input', setSizeHandler);\r\n    blankPositionSelector.topRight.addEventListener('input', setSizeHandler);\r\n    blankPositionSelector.bottomLeft.addEventListener('input', setSizeHandler);\r\n    blankPositionSelector.bottomRight.addEventListener('input', setSizeHandler);\r\n    sizeInput.addEventListener('change', setSizeHandler);\r\n    puzzleSelector.addEventListener('change', ev => {\r\n        game.setPuzzleSet(puzzleSets[puzzleSelector.value]);\r\n        renderPreview(puzzleSets[puzzleSelector.value]);\r\n        resetButtons();\r\n    });\r\n    labelSelector.none.addEventListener('input', ev => {\r\n        game.showLabel = false;\r\n    });\r\n    labelSelector.phone.addEventListener('input', ev => {\r\n        game.showLabel = true;\r\n        game.assignLabel(false);\r\n    });\r\n    labelSelector.keypad.addEventListener('input', ev => {\r\n        game.showLabel = true;\r\n        game.assignLabel(true);\r\n    });\r\n    let puzzleSet = puzzleSets[puzzleSelector.value];\r\n    let size = sizeInput.valueAsNumber;\r\n    let scale = gameCanvas.width / gameCanvas.getBoundingClientRect().width;\r\n    game = new _Game__WEBPACK_IMPORTED_MODULE_2__[\"default\"](size, puzzleSet, horizontalMargin, verticalMargin, boardLength, timerHeight);\r\n    game.completeHandlers.push(resetButtons);\r\n    renderPreview(puzzleSet);\r\n    input = new _Input__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\r\n    input.scale = scale;\r\n    input.connect(gameCanvas, game);\r\n    clock = new _RAFPulseClock__WEBPACK_IMPORTED_MODULE_1__[\"default\"](t => {\r\n        input.update();\r\n        game.update(t, input);\r\n        game.render(gameContext);\r\n    });\r\n    clock.run();\r\n    window.game = game;\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHM/NzFiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDb0M7QUFDUTtBQUNsQjtBQUNPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0Esa0NBQWtDLGtEQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRCxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFJO0FBQ25CO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQVU7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQixzREFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbmltcG9ydCBQdXp6bGVTZXQgZnJvbSAnLi9QdXp6bGVTZXQnO1xyXG5pbXBvcnQgUkFGUHVsc2VDbG9jayBmcm9tICcuL1JBRlB1bHNlQ2xvY2snO1xyXG5pbXBvcnQgR2FtZSBmcm9tICcuL0dhbWUnO1xyXG5pbXBvcnQgTW91c2VJbnB1dCBmcm9tICcuL0lucHV0JztcclxubGV0IGdhbWU7XHJcbmxldCBjbG9jaztcclxubGV0IGlucHV0O1xyXG5jb25zdCBbZ2FtZUNhbnZhcywgcHJldmlld0NhbnZhc10gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyk7XHJcbmNvbnN0IGdhbWVDb250ZXh0ID0gZ2FtZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5jb25zdCBwcmV2aWV3Q29udGV4dCA9IHByZXZpZXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuZ2FtZUNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbmdhbWVDb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG5jb25zdCBob3Jpem9udGFsTWFyZ2luID0gMjA7XHJcbmNvbnN0IHZlcnRpY2FsTWFyZ2luID0gMjA7XHJcbmNvbnN0IGJvYXJkTGVuZ3RoID0gZ2FtZUNhbnZhcy53aWR0aCAtIGhvcml6b250YWxNYXJnaW4gKiAyO1xyXG5jb25zdCB0aW1lckhlaWdodCA9IGdhbWVDYW52YXMuaGVpZ2h0IC8gNTtcclxuY29uc3Qgc2l6ZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpemUnKTtcclxuY29uc3QgcHV6emxlU2VsZWN0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHV6emxlLXNlbGVjdG9yJyk7XHJcbmNvbnN0IHN0YXJ0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0Jyk7XHJcbmNvbnN0IHN0b3BCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RvcCcpO1xyXG5jb25zdCBibGFua1Bvc2l0aW9uU2VsZWN0b3IgPSB7XHJcbiAgICB0b3BMZWZ0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmxhbmstcG9zLXRvcC1sZWZ0JyksXHJcbiAgICB0b3BSaWdodDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JsYW5rLXBvcy10b3AtcmlnaHQnKSxcclxuICAgIGJvdHRvbUxlZnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdibGFuay1wb3MtYm90dG9tLWxlZnQnKSxcclxuICAgIGJvdHRvbVJpZ2h0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmxhbmstcG9zLWJvdHRvbS1yaWdodCcpLFxyXG59O1xyXG5mdW5jdGlvbiBkZWNvZGVCbGFuaygpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgYmxhbmtQb3NpdGlvblNlbGVjdG9yLmJvdHRvbUxlZnQuY2hlY2tlZCB8fCBibGFua1Bvc2l0aW9uU2VsZWN0b3IuYm90dG9tUmlnaHQuY2hlY2tlZCxcclxuICAgICAgICBibGFua1Bvc2l0aW9uU2VsZWN0b3IudG9wUmlnaHQuY2hlY2tlZCB8fCBibGFua1Bvc2l0aW9uU2VsZWN0b3IuYm90dG9tUmlnaHQuY2hlY2tlZFxyXG4gICAgXTtcclxufVxyXG5jb25zdCBsYWJlbFNlbGVjdG9yID0ge1xyXG4gICAgbm9uZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Nob3ctbGFiZWwtbm9uZScpLFxyXG4gICAgcGhvbmU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWxhYmVsLXBob25lJyksXHJcbiAgICBrZXlwYWQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG93LWxhYmVsLWtleXBhZCcpXHJcbn07XHJcbmZ1bmN0aW9uIGxvYWRQdXp6bGVTZXRzKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBwdXp6bGVTZXRzID0gW107XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCgncHV6emxlc2V0Lmpzb24nKTtcclxuICAgICAgICBjb25zdCBwdXp6bGVTZXREYXRhQXJyYXkgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdXp6bGVTZXREYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHV6emxlU2V0ID0gcHV6emxlU2V0RGF0YUFycmF5W2ldO1xyXG4gICAgICAgICAgICBwdXp6bGVTZXQuX19wcm90b19fID0gUHV6emxlU2V0LnByb3RvdHlwZTtcclxuICAgICAgICAgICAgcHV6emxlU2V0cy5wdXNoKHB1enpsZVNldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdE9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xyXG4gICAgICAgICAgICBzZWxlY3RPcHRpb24udmFsdWUgPSBpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHNlbGVjdE9wdGlvbi5pbm5lclRleHQgPSBwdXp6bGVTZXQudGl0bGU7XHJcbiAgICAgICAgICAgIHB1enpsZVNlbGVjdG9yLmFwcGVuZENoaWxkKHNlbGVjdE9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHB1enpsZVNldHMubWFwKHYgPT4gdi53YWl0Rm9ySW1hZ2VMb2FkKCkpKTtcclxuICAgICAgICByZXR1cm4gcHV6emxlU2V0cztcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0QnV0dG9ucygpIHtcclxuICAgIHN0YXJ0QnV0dG9uLmlubmVyVGV4dCA9ICfsi5zsnpHtlZjquLAnO1xyXG4gICAgc3RvcEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gc2V0U2l6ZUhhbmRsZXIoKSB7XHJcbiAgICBnYW1lLnNldFNpemUoc2l6ZUlucHV0LnZhbHVlQXNOdW1iZXIsIC4uLmRlY29kZUJsYW5rKCkpO1xyXG4gICAgcmVzZXRCdXR0b25zKCk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyUHJldmlldyh7IHRleHR1cmUsIGxlZnQsIHRvcCwgc2l6ZSB9KSB7XHJcbiAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBwcmV2aWV3Q2FudmFzO1xyXG4gICAgcHJldmlld0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgcHJldmlld0NvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIGxlZnQsIHRvcCwgc2l6ZSwgc2l6ZSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4sIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbiAqIDIsIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luICogMik7XHJcbn1cclxubG9hZFB1enpsZVNldHMoKS50aGVuKChwdXp6bGVTZXRzKSA9PiB7XHJcbiAgICBzdGFydEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ID0+IHtcclxuICAgICAgICBnYW1lLnNodWZmbGUoKTtcclxuICAgICAgICBnYW1lLmluaXRQaWVjZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgZ2FtZS5zdGFydChldi50aW1lU3RhbXApO1xyXG4gICAgICAgIHN0YXJ0QnV0dG9uLmlubmVyVGV4dCA9ICfri6Tsi5ztlZjquLAnO1xyXG4gICAgICAgIHN0b3BCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgc3RvcEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ID0+IHtcclxuICAgICAgICBnYW1lLmVuZChldi50aW1lU3RhbXApO1xyXG4gICAgICAgIHJlc2V0QnV0dG9ucygpO1xyXG4gICAgfSk7XHJcbiAgICBibGFua1Bvc2l0aW9uU2VsZWN0b3IudG9wTGVmdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHNldFNpemVIYW5kbGVyKTtcclxuICAgIGJsYW5rUG9zaXRpb25TZWxlY3Rvci50b3BSaWdodC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHNldFNpemVIYW5kbGVyKTtcclxuICAgIGJsYW5rUG9zaXRpb25TZWxlY3Rvci5ib3R0b21MZWZ0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0Jywgc2V0U2l6ZUhhbmRsZXIpO1xyXG4gICAgYmxhbmtQb3NpdGlvblNlbGVjdG9yLmJvdHRvbVJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0Jywgc2V0U2l6ZUhhbmRsZXIpO1xyXG4gICAgc2l6ZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHNldFNpemVIYW5kbGVyKTtcclxuICAgIHB1enpsZVNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGV2ID0+IHtcclxuICAgICAgICBnYW1lLnNldFB1enpsZVNldChwdXp6bGVTZXRzW3B1enpsZVNlbGVjdG9yLnZhbHVlXSk7XHJcbiAgICAgICAgcmVuZGVyUHJldmlldyhwdXp6bGVTZXRzW3B1enpsZVNlbGVjdG9yLnZhbHVlXSk7XHJcbiAgICAgICAgcmVzZXRCdXR0b25zKCk7XHJcbiAgICB9KTtcclxuICAgIGxhYmVsU2VsZWN0b3Iubm9uZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGV2ID0+IHtcclxuICAgICAgICBnYW1lLnNob3dMYWJlbCA9IGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgICBsYWJlbFNlbGVjdG9yLnBob25lLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZXYgPT4ge1xyXG4gICAgICAgIGdhbWUuc2hvd0xhYmVsID0gdHJ1ZTtcclxuICAgICAgICBnYW1lLmFzc2lnbkxhYmVsKGZhbHNlKTtcclxuICAgIH0pO1xyXG4gICAgbGFiZWxTZWxlY3Rvci5rZXlwYWQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBldiA9PiB7XHJcbiAgICAgICAgZ2FtZS5zaG93TGFiZWwgPSB0cnVlO1xyXG4gICAgICAgIGdhbWUuYXNzaWduTGFiZWwodHJ1ZSk7XHJcbiAgICB9KTtcclxuICAgIGxldCBwdXp6bGVTZXQgPSBwdXp6bGVTZXRzW3B1enpsZVNlbGVjdG9yLnZhbHVlXTtcclxuICAgIGxldCBzaXplID0gc2l6ZUlucHV0LnZhbHVlQXNOdW1iZXI7XHJcbiAgICBsZXQgc2NhbGUgPSBnYW1lQ2FudmFzLndpZHRoIC8gZ2FtZUNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuICAgIGdhbWUgPSBuZXcgR2FtZShzaXplLCBwdXp6bGVTZXQsIGhvcml6b250YWxNYXJnaW4sIHZlcnRpY2FsTWFyZ2luLCBib2FyZExlbmd0aCwgdGltZXJIZWlnaHQpO1xyXG4gICAgZ2FtZS5jb21wbGV0ZUhhbmRsZXJzLnB1c2gocmVzZXRCdXR0b25zKTtcclxuICAgIHJlbmRlclByZXZpZXcocHV6emxlU2V0KTtcclxuICAgIGlucHV0ID0gbmV3IE1vdXNlSW5wdXQoKTtcclxuICAgIGlucHV0LnNjYWxlID0gc2NhbGU7XHJcbiAgICBpbnB1dC5jb25uZWN0KGdhbWVDYW52YXMsIGdhbWUpO1xyXG4gICAgY2xvY2sgPSBuZXcgUkFGUHVsc2VDbG9jayh0ID0+IHtcclxuICAgICAgICBpbnB1dC51cGRhdGUoKTtcclxuICAgICAgICBnYW1lLnVwZGF0ZSh0LCBpbnB1dCk7XHJcbiAgICAgICAgZ2FtZS5yZW5kZXIoZ2FtZUNvbnRleHQpO1xyXG4gICAgfSk7XHJcbiAgICBjbG9jay5ydW4oKTtcclxuICAgIHdpbmRvdy5nYW1lID0gZ2FtZTtcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! exports provided: getRowCol, getPosition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRowCol\", function() { return getRowCol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPosition\", function() { return getPosition; });\nfunction quantize(pos, parentSize, offset, divideBy) {\r\n    let n = Math.floor((pos - offset) / (parentSize / divideBy));\r\n    return n;\r\n}\r\n/**\r\n * 왼쪽 경계가 left, 오른쪽 경계가 top인 정사각형 parentSize를 정사각행렬 꼴로 divideBy만큼 나누었을 때, 좌표 (x, y)가 속한 행렬 위치\r\n */\r\nfunction getRowCol(x, y, parentSize, left, top, divideBy) {\r\n    return [\r\n        quantize(y, parentSize, top, divideBy),\r\n        quantize(x, parentSize, left, divideBy)\r\n    ];\r\n}\r\n/**\r\n * 왼쪽 경계가 left, 오른쪽 경계가 top인 정사각형 parentSize를 정사각행렬 꼴로 divideBy만큼 나누었을 때, row행 col열에 있는 부분 정사각형의 왼쪽 위 좌표\r\n */\r\nfunction getPosition(row, col, parentSize, left, top, divideBy) {\r\n    let d = parentSize / divideBy;\r\n    return [left + col * d, top + row * d];\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMudHM/MjA1MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL3V0aWxzLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcXVhbnRpemUocG9zLCBwYXJlbnRTaXplLCBvZmZzZXQsIGRpdmlkZUJ5KSB7XHJcbiAgICBsZXQgbiA9IE1hdGguZmxvb3IoKHBvcyAtIG9mZnNldCkgLyAocGFyZW50U2l6ZSAvIGRpdmlkZUJ5KSk7XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG4vKipcclxuICog7Jm87Kq9IOqyveqzhOqwgCBsZWZ0LCDsmKTrpbjsqr0g6rK96rOE6rCAIHRvcOyduCDsoJXsgqzqsIHtmJUgcGFyZW50U2l6ZeulvCDsoJXsgqzqsIHtlonroKwg6ry066GcIGRpdmlkZUJ566eM7YG8IOuCmOuIhOyXiOydhCDrlYwsIOyijO2RnCAoeCwgeSnqsIAg7IaN7ZWcIO2WieugrCDsnITsuZhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dDb2woeCwgeSwgcGFyZW50U2l6ZSwgbGVmdCwgdG9wLCBkaXZpZGVCeSkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBxdWFudGl6ZSh5LCBwYXJlbnRTaXplLCB0b3AsIGRpdmlkZUJ5KSxcclxuICAgICAgICBxdWFudGl6ZSh4LCBwYXJlbnRTaXplLCBsZWZ0LCBkaXZpZGVCeSlcclxuICAgIF07XHJcbn1cclxuLyoqXHJcbiAqIOyZvOyqvSDqsr3qs4TqsIAgbGVmdCwg7Jik66W47Kq9IOqyveqzhOqwgCB0b3Dsnbgg7KCV7IKs6rCB7ZiVIHBhcmVudFNpemXrpbwg7KCV7IKs6rCB7ZaJ66CsIOq8tOuhnCBkaXZpZGVCeeunjO2BvCDrgpjriITsl4jsnYQg65WMLCByb3ftlokgY29s7Je07JeQIOyeiOuKlCDrtoDrtoQg7KCV7IKs6rCB7ZiV7J2YIOyZvOyqvSDsnIQg7KKM7ZGcXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24ocm93LCBjb2wsIHBhcmVudFNpemUsIGxlZnQsIHRvcCwgZGl2aWRlQnkpIHtcclxuICAgIGxldCBkID0gcGFyZW50U2l6ZSAvIGRpdmlkZUJ5O1xyXG4gICAgcmV0dXJuIFtsZWZ0ICsgY29sICogZCwgdG9wICsgcm93ICogZF07XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils.ts\n");

/***/ })

/******/ });